{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Structure = exports.Unpacker = exports.Packer = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar channel_1 = require(\"../channel\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar objectUtil = neo4j_driver_core_1.internal.objectUtil;\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar TINY_STRING = 0x80;\nvar TINY_LIST = 0x90;\nvar TINY_MAP = 0xa0;\nvar TINY_STRUCT = 0xb0;\nvar NULL = 0xc0;\nvar FLOAT_64 = 0xc1;\nvar FALSE = 0xc2;\nvar TRUE = 0xc3;\nvar INT_8 = 0xc8;\nvar INT_16 = 0xc9;\nvar INT_32 = 0xca;\nvar INT_64 = 0xcb;\nvar STRING_8 = 0xd0;\nvar STRING_16 = 0xd1;\nvar STRING_32 = 0xd2;\nvar LIST_8 = 0xd4;\nvar LIST_16 = 0xd5;\nvar LIST_32 = 0xd6;\nvar BYTES_8 = 0xcc;\nvar BYTES_16 = 0xcd;\nvar BYTES_32 = 0xce;\nvar MAP_8 = 0xd8;\nvar MAP_16 = 0xd9;\nvar MAP_32 = 0xda;\nvar STRUCT_8 = 0xdc;\nvar STRUCT_16 = 0xdd;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * A Structure have a signature and fields.\n * @access private\n */\nvar Structure = /** @class */function () {\n  /**\n   * Create new instance\n   */\n  function Structure(signature, fields) {\n    this.signature = signature;\n    this.fields = fields;\n  }\n  Structure.prototype.toString = function () {\n    var fieldStr = '';\n    for (var i = 0; i < this.fields.length; i++) {\n      if (i > 0) {\n        fieldStr += ', ';\n      }\n      fieldStr += this.fields[i];\n    }\n    return 'Structure(' + this.signature + ', [' + fieldStr + '])';\n  };\n  return Structure;\n}();\nexports.Structure = Structure;\n/**\n * Class to pack\n * @access private\n */\nvar Packer = /** @class */function () {\n  /**\n   * @constructor\n   * @param {Chunker} channel the chunker backed by a network channel.\n   */\n  function Packer(channel) {\n    this._ch = channel;\n    this._byteArraysSupported = true;\n  }\n  /**\n   * Creates a packable function out of the provided value\n   * @param x the value to pack\n   * @returns Function\n   */\n  Packer.prototype.packable = function (x) {\n    var _this = this;\n    if (x === null) {\n      return function () {\n        return _this._ch.writeUInt8(NULL);\n      };\n    } else if (x === true) {\n      return function () {\n        return _this._ch.writeUInt8(TRUE);\n      };\n    } else if (x === false) {\n      return function () {\n        return _this._ch.writeUInt8(FALSE);\n      };\n    } else if (typeof x === 'number') {\n      return function () {\n        return _this.packFloat(x);\n      };\n    } else if (typeof x === 'string') {\n      return function () {\n        return _this.packString(x);\n      };\n    } else if (typeof x === 'bigint') {\n      return function () {\n        return _this.packInteger((0, neo4j_driver_core_1.int)(x));\n      };\n    } else if ((0, neo4j_driver_core_1.isInt)(x)) {\n      return function () {\n        return _this.packInteger(x);\n      };\n    } else if (x instanceof Int8Array) {\n      return function () {\n        return _this.packBytes(x);\n      };\n    } else if (x instanceof Array) {\n      return function () {\n        _this.packListHeader(x.length);\n        for (var i_1 = 0; i_1 < x.length; i_1++) {\n          _this.packable(x[i_1] === undefined ? null : x[i_1])();\n        }\n      };\n    } else if (isIterable(x)) {\n      return this.packableIterable(x);\n    } else if (x instanceof neo4j_driver_core_1.Node) {\n      return this._nonPackableValue(\"It is not allowed to pass nodes in query parameters, given: \" + x);\n    } else if (x instanceof neo4j_driver_core_1.Relationship) {\n      return this._nonPackableValue(\"It is not allowed to pass relationships in query parameters, given: \" + x);\n    } else if (x instanceof neo4j_driver_core_1.Path) {\n      return this._nonPackableValue(\"It is not allowed to pass paths in query parameters, given: \" + x);\n    } else if (x instanceof Structure) {\n      var packableFields = [];\n      for (var i = 0; i < x.fields.length; i++) {\n        packableFields[i] = this.packable(x.fields[i]);\n      }\n      return function () {\n        return _this.packStruct(x.signature, packableFields);\n      };\n    } else if (typeof x === 'object') {\n      return function () {\n        var keys = Object.keys(x);\n        var count = 0;\n        for (var i_2 = 0; i_2 < keys.length; i_2++) {\n          if (x[keys[i_2]] !== undefined) {\n            count++;\n          }\n        }\n        _this.packMapHeader(count);\n        for (var i_3 = 0; i_3 < keys.length; i_3++) {\n          var key = keys[i_3];\n          if (x[key] !== undefined) {\n            _this.packString(key);\n            _this.packable(x[key])();\n          }\n        }\n      };\n    } else {\n      return this._nonPackableValue(\"Unable to pack the given value: \" + x);\n    }\n  };\n  Packer.prototype.packableIterable = function (iterable) {\n    try {\n      var array = Array.from(iterable);\n      return this.packable(array);\n    } catch (e) {\n      // handle errors from iterable to array conversion\n      throw (0, neo4j_driver_core_1.newError)(\"Cannot pack given iterable, \" + e.message + \": \" + iterable);\n    }\n  };\n  /**\n   * Packs a struct\n   * @param signature the signature of the struct\n   * @param packableFields the fields of the struct, make sure you call `packable on all fields`\n   */\n  Packer.prototype.packStruct = function (signature, packableFields) {\n    packableFields = packableFields || [];\n    this.packStructHeader(packableFields.length, signature);\n    for (var i = 0; i < packableFields.length; i++) {\n      packableFields[i]();\n    }\n  };\n  Packer.prototype.packInteger = function (x) {\n    var high = x.high;\n    var low = x.low;\n    if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {\n      this._ch.writeInt8(low);\n    } else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {\n      this._ch.writeUInt8(INT_8);\n      this._ch.writeInt8(low);\n    } else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {\n      this._ch.writeUInt8(INT_16);\n      this._ch.writeInt16(low);\n    } else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {\n      this._ch.writeUInt8(INT_32);\n      this._ch.writeInt32(low);\n    } else {\n      this._ch.writeUInt8(INT_64);\n      this._ch.writeInt32(high);\n      this._ch.writeInt32(low);\n    }\n  };\n  Packer.prototype.packFloat = function (x) {\n    this._ch.writeUInt8(FLOAT_64);\n    this._ch.writeFloat64(x);\n  };\n  Packer.prototype.packString = function (x) {\n    var bytes = channel_1.utf8.encode(x);\n    var size = bytes.length;\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_STRING | size);\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(STRING_8);\n      this._ch.writeUInt8(size);\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(STRING_16);\n      this._ch.writeUInt8(size / 256 >> 0);\n      this._ch.writeUInt8(size % 256);\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(STRING_32);\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n      this._ch.writeBytes(bytes);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('UTF-8 strings of size ' + size + ' are not supported');\n    }\n  };\n  Packer.prototype.packListHeader = function (size) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_LIST | size);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(LIST_8);\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(LIST_16);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(LIST_32);\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Lists of size ' + size + ' are not supported');\n    }\n  };\n  Packer.prototype.packBytes = function (array) {\n    if (this._byteArraysSupported) {\n      this.packBytesHeader(array.length);\n      for (var i = 0; i < array.length; i++) {\n        this._ch.writeInt8(array[i]);\n      }\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Byte arrays are not supported by the database this driver is connected to');\n    }\n  };\n  Packer.prototype.packBytesHeader = function (size) {\n    if (size < 0x100) {\n      this._ch.writeUInt8(BYTES_8);\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(BYTES_16);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(BYTES_32);\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Byte arrays of size ' + size + ' are not supported');\n    }\n  };\n  Packer.prototype.packMapHeader = function (size) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_MAP | size);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(MAP_8);\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(MAP_16);\n      this._ch.writeUInt8(size / 256 >> 0);\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(MAP_32);\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Maps of size ' + size + ' are not supported');\n    }\n  };\n  Packer.prototype.packStructHeader = function (size, signature) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_STRUCT | size);\n      this._ch.writeUInt8(signature);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(STRUCT_8);\n      this._ch.writeUInt8(size);\n      this._ch.writeUInt8(signature);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(STRUCT_16);\n      this._ch.writeUInt8(size / 256 >> 0);\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Structures of size ' + size + ' are not supported');\n    }\n  };\n  Packer.prototype.disableByteArrays = function () {\n    this._byteArraysSupported = false;\n  };\n  Packer.prototype._nonPackableValue = function (message) {\n    return function () {\n      throw (0, neo4j_driver_core_1.newError)(message, PROTOCOL_ERROR);\n    };\n  };\n  return Packer;\n}();\nexports.Packer = Packer;\n/**\n * Class to unpack\n * @access private\n */\nvar Unpacker = /** @class */function () {\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n   */\n  function Unpacker(disableLosslessIntegers, useBigInt) {\n    if (disableLosslessIntegers === void 0) {\n      disableLosslessIntegers = false;\n    }\n    if (useBigInt === void 0) {\n      useBigInt = false;\n    }\n    this._disableLosslessIntegers = disableLosslessIntegers;\n    this._useBigInt = useBigInt;\n  }\n  Unpacker.prototype.unpack = function (buffer) {\n    var marker = buffer.readUInt8();\n    var markerHigh = marker & 0xf0;\n    var markerLow = marker & 0x0f;\n    if (marker === NULL) {\n      return null;\n    }\n    var boolean = this._unpackBoolean(marker);\n    if (boolean !== null) {\n      return boolean;\n    }\n    var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);\n    if (numberOrInteger !== null) {\n      if ((0, neo4j_driver_core_1.isInt)(numberOrInteger)) {\n        if (this._useBigInt) {\n          return numberOrInteger.toBigInt();\n        } else if (this._disableLosslessIntegers) {\n          return numberOrInteger.toNumberOrInfinity();\n        }\n      }\n      return numberOrInteger;\n    }\n    var string = this._unpackString(marker, markerHigh, markerLow, buffer);\n    if (string !== null) {\n      return string;\n    }\n    var list = this._unpackList(marker, markerHigh, markerLow, buffer);\n    if (list !== null) {\n      return list;\n    }\n    var byteArray = this._unpackByteArray(marker, buffer);\n    if (byteArray !== null) {\n      return byteArray;\n    }\n    var map = this._unpackMap(marker, markerHigh, markerLow, buffer);\n    if (map !== null) {\n      return map;\n    }\n    var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);\n    if (struct !== null) {\n      return struct;\n    }\n    throw (0, neo4j_driver_core_1.newError)('Unknown packed value with marker ' + marker.toString(16));\n  };\n  Unpacker.prototype.unpackInteger = function (buffer) {\n    var marker = buffer.readUInt8();\n    var result = this._unpackInteger(marker, buffer);\n    if (result == null) {\n      throw (0, neo4j_driver_core_1.newError)('Unable to unpack integer value with marker ' + marker.toString(16));\n    }\n    return result;\n  };\n  Unpacker.prototype._unpackBoolean = function (marker) {\n    if (marker === TRUE) {\n      return true;\n    } else if (marker === FALSE) {\n      return false;\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackNumberOrInteger = function (marker, buffer) {\n    if (marker === FLOAT_64) {\n      return buffer.readFloat64();\n    } else {\n      return this._unpackInteger(marker, buffer);\n    }\n  };\n  Unpacker.prototype._unpackInteger = function (marker, buffer) {\n    if (marker >= 0 && marker < 128) {\n      return (0, neo4j_driver_core_1.int)(marker);\n    } else if (marker >= 240 && marker < 256) {\n      return (0, neo4j_driver_core_1.int)(marker - 256);\n    } else if (marker === INT_8) {\n      return (0, neo4j_driver_core_1.int)(buffer.readInt8());\n    } else if (marker === INT_16) {\n      return (0, neo4j_driver_core_1.int)(buffer.readInt16());\n    } else if (marker === INT_32) {\n      var b = buffer.readInt32();\n      return (0, neo4j_driver_core_1.int)(b);\n    } else if (marker === INT_64) {\n      var high = buffer.readInt32();\n      var low = buffer.readInt32();\n      return new neo4j_driver_core_1.Integer(low, high);\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackString = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_STRING) {\n      return channel_1.utf8.decode(buffer, markerLow);\n    } else if (marker === STRING_8) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt8());\n    } else if (marker === STRING_16) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt16());\n    } else if (marker === STRING_32) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt32());\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackList = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_LIST) {\n      return this._unpackListWithSize(markerLow, buffer);\n    } else if (marker === LIST_8) {\n      return this._unpackListWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === LIST_16) {\n      return this._unpackListWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === LIST_32) {\n      return this._unpackListWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackListWithSize = function (size, buffer) {\n    var value = [];\n    for (var i = 0; i < size; i++) {\n      value.push(this.unpack(buffer));\n    }\n    return value;\n  };\n  Unpacker.prototype._unpackByteArray = function (marker, buffer) {\n    if (marker === BYTES_8) {\n      return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === BYTES_16) {\n      return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === BYTES_32) {\n      return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackByteArrayWithSize = function (size, buffer) {\n    var value = new Int8Array(size);\n    for (var i = 0; i < size; i++) {\n      value[i] = buffer.readInt8();\n    }\n    return value;\n  };\n  Unpacker.prototype._unpackMap = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_MAP) {\n      return this._unpackMapWithSize(markerLow, buffer);\n    } else if (marker === MAP_8) {\n      return this._unpackMapWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === MAP_16) {\n      return this._unpackMapWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === MAP_32) {\n      return this._unpackMapWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackMapWithSize = function (size, buffer) {\n    var value = {};\n    for (var i = 0; i < size; i++) {\n      var key = this.unpack(buffer);\n      value[key] = this.unpack(buffer);\n    }\n    return value;\n  };\n  Unpacker.prototype._unpackStruct = function (marker, markerHigh, markerLow, buffer) {\n    try {\n      if (markerHigh === TINY_STRUCT) {\n        return this._unpackStructWithSize(markerLow, buffer);\n      } else if (marker === STRUCT_8) {\n        return this._unpackStructWithSize(buffer.readUInt8(), buffer);\n      } else if (marker === STRUCT_16) {\n        return this._unpackStructWithSize(buffer.readUInt16(), buffer);\n      } else {\n        return null;\n      }\n    } catch (error) {\n      return objectUtil.createBrokenObject(error);\n    }\n  };\n  Unpacker.prototype._unpackStructWithSize = function (structSize, buffer) {\n    var signature = buffer.readUInt8();\n    if (signature === NODE) {\n      return this._unpackNode(structSize, buffer);\n    } else if (signature === RELATIONSHIP) {\n      return this._unpackRelationship(structSize, buffer);\n    } else if (signature === UNBOUND_RELATIONSHIP) {\n      return this._unpackUnboundRelationship(structSize, buffer);\n    } else if (signature === PATH) {\n      return this._unpackPath(structSize, buffer);\n    } else {\n      return this._unpackUnknownStruct(signature, structSize, buffer);\n    }\n  };\n  Unpacker.prototype._unpackNode = function (structSize, buffer) {\n    this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);\n    return new neo4j_driver_core_1.Node(this.unpack(buffer),\n    // Identity\n    this.unpack(buffer),\n    // Labels\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackRelationship = function (structSize, buffer) {\n    this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);\n    return new neo4j_driver_core_1.Relationship(this.unpack(buffer),\n    // Identity\n    this.unpack(buffer),\n    // Start Node Identity\n    this.unpack(buffer),\n    // End Node Identity\n    this.unpack(buffer),\n    // Type\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackUnboundRelationship = function (structSize, buffer) {\n    this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);\n    return new neo4j_driver_core_1.UnboundRelationship(this.unpack(buffer),\n    // Identity\n    this.unpack(buffer),\n    // Type\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackPath = function (structSize, buffer) {\n    this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);\n    var nodes = this.unpack(buffer);\n    var rels = this.unpack(buffer);\n    var sequence = this.unpack(buffer);\n    var segments = [];\n    var prevNode = nodes[0];\n    for (var i = 0; i < sequence.length; i += 2) {\n      var nextNode = nodes[sequence[i + 1]];\n      var relIndex = (0, neo4j_driver_core_1.toNumber)(sequence[i]);\n      var rel = void 0;\n      if (relIndex > 0) {\n        rel = rels[relIndex - 1];\n        if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n          // To avoid duplication, relationships in a path do not contain\n          // information about their start and end nodes, that's instead\n          // inferred from the path sequence. This is us inferring (and,\n          // for performance reasons remembering) the start/end of a rel.\n          rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);\n        }\n      } else {\n        rel = rels[-relIndex - 1];\n        if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n          // See above\n          rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);\n        }\n      }\n      // Done hydrating one path segment.\n      segments.push(new neo4j_driver_core_1.PathSegment(prevNode, rel, nextNode));\n      prevNode = nextNode;\n    }\n    return new neo4j_driver_core_1.Path(nodes[0], nodes[nodes.length - 1], segments);\n  };\n  Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n    var result = new Structure(signature, []);\n    for (var i = 0; i < structSize; i++) {\n      result.fields.push(this.unpack(buffer));\n    }\n    return result;\n  };\n  Unpacker.prototype._verifyStructSize = function (structName, expectedSize, actualSize) {\n    if (expectedSize !== actualSize) {\n      throw (0, neo4j_driver_core_1.newError)(\"Wrong struct size for \" + structName + \", expected \" + expectedSize + \" but was \" + actualSize, PROTOCOL_ERROR);\n    }\n  };\n  return Unpacker;\n}();\nexports.Unpacker = Unpacker;\nfunction isIterable(obj) {\n  if (obj == null) {\n    return false;\n  }\n  return typeof obj[Symbol.iterator] === 'function';\n}","map":null,"metadata":{},"sourceType":"script"}