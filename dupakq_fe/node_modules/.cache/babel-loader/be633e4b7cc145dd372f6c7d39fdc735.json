{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2]) _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar error_1 = require(\"./error\");\nfunction generateFieldLookup(keys) {\n  var lookup = {};\n  keys.forEach(function (name, idx) {\n    lookup[name] = idx;\n  });\n  return lookup;\n}\n/**\n * Records make up the contents of the {@link Result}, and is how you access\n * the output of a query. A simple query might yield a result stream\n * with a single record, for instance:\n *\n *     MATCH (u:User) RETURN u.name, u.age\n *\n * This returns a stream of records with two fields, named `u.name` and `u.age`,\n * each record represents one user found by the query above. You can access\n * the values of each field either by name:\n *\n *     record.get(\"u.name\")\n *\n * Or by it's position:\n *\n *     record.get(0)\n *\n * @access public\n */\nvar Record = /** @class */function () {\n  /**\n   * Create a new record object.\n   * @constructor\n   * @protected\n   * @param {string[]} keys An array of field keys, in the order the fields appear in the record\n   * @param {Array} fields An array of field values\n   * @param {Object} fieldLookup An object of fieldName -> value index, used to map\n   *                            field names to values. If this is null, one will be\n   *                            generated.\n   */\n  function Record(keys, fields, fieldLookup) {\n    /**\n     * Field keys, in the order the fields appear in the record.\n     * @type {string[]}\n     */\n    this.keys = keys;\n    /**\n     * Number of fields\n     * @type {Number}\n     */\n    this.length = keys.length;\n    this._fields = fields;\n    this._fieldLookup = fieldLookup || generateFieldLookup(keys);\n  }\n  /**\n   * Run the given function for each field in this record. The function\n   * will get three arguments - the value, the key and this record, in that\n   * order.\n   *\n   * @param {function(value: Object, key: string, record: Record)} visitor the function to apply to each field.\n   * @returns {void} Nothing\n   */\n  Record.prototype.forEach = function (visitor) {\n    var e_1, _a;\n    try {\n      for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          key = _d[0],\n          value = _d[1];\n        visitor(value, key, this);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  /**\n   * Run the given function for each field in this record. The function\n   * will get three arguments - the value, the key and this record, in that\n   * order.\n   *\n   * @param {function(value: Object, key: string, record: Record)} visitor the function to apply on each field\n   * and return a value that is saved to the returned Array.\n   *\n   * @returns {Array}\n   */\n  Record.prototype.map = function (visitor) {\n    var e_2, _a;\n    var resultArray = [];\n    try {\n      for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          key = _d[0],\n          value = _d[1];\n        resultArray.push(visitor(value, key, this));\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return resultArray;\n  };\n  /**\n   * Iterate over results. Each iteration will yield an array\n   * of exactly two items - the key, and the value (in order).\n   *\n   * @generator\n   * @returns {IterableIterator<Array>}\n   */\n  Record.prototype.entries = function () {\n    var i;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          i = 0;\n          _a.label = 1;\n        case 1:\n          if (!(i < this.keys.length)) return [3 /*break*/, 4];\n          return [4 /*yield*/, [this.keys[i], this._fields[i]]];\n        case 2:\n          _a.sent();\n          _a.label = 3;\n        case 3:\n          i++;\n          return [3 /*break*/, 1];\n        case 4:\n          return [2 /*return*/];\n      }\n    });\n  };\n  /**\n   * Iterate over values.\n   *\n   * @generator\n   * @returns {IterableIterator<Object>}\n   */\n  Record.prototype.values = function () {\n    var i;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          i = 0;\n          _a.label = 1;\n        case 1:\n          if (!(i < this.keys.length)) return [3 /*break*/, 4];\n          return [4 /*yield*/, this._fields[i]];\n        case 2:\n          _a.sent();\n          _a.label = 3;\n        case 3:\n          i++;\n          return [3 /*break*/, 1];\n        case 4:\n          return [2 /*return*/];\n      }\n    });\n  };\n  /**\n   * Iterate over values. Delegates to {@link Record#values}\n   *\n   * @generator\n   * @returns {IterableIterator<Object>}\n   */\n  Record.prototype[Symbol.iterator] = function () {\n    var i;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          i = 0;\n          _a.label = 1;\n        case 1:\n          if (!(i < this.keys.length)) return [3 /*break*/, 4];\n          return [4 /*yield*/, this._fields[i]];\n        case 2:\n          _a.sent();\n          _a.label = 3;\n        case 3:\n          i++;\n          return [3 /*break*/, 1];\n        case 4:\n          return [2 /*return*/];\n      }\n    });\n  };\n  /**\n   * Generates an object out of the current Record\n   *\n   * @returns {Object}\n   */\n  Record.prototype.toObject = function () {\n    var e_3, _a;\n    var obj = {};\n    try {\n      for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          key = _d[0],\n          value = _d[1];\n        obj[key] = value;\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    return obj;\n  };\n  /**\n   * Get a value from this record, either by index or by field key.\n   *\n   * @param {string|Number} key Field key, or the index of the field.\n   * @returns {*}\n   */\n  Record.prototype.get = function (key) {\n    var index;\n    if (!(typeof key === 'number')) {\n      index = this._fieldLookup[key];\n      if (index === undefined) {\n        throw (0, error_1.newError)(\"This record has no field with key '\" + key + \"', available key are: [\" + this.keys + '].');\n      }\n    } else {\n      index = key;\n    }\n    if (index > this._fields.length - 1 || index < 0) {\n      throw (0, error_1.newError)(\"This record has no field with index '\" + index + \"'. Remember that indexes start at `0`, \" + 'and make sure your query returns records in the shape you meant it to.');\n    }\n    return this._fields[index];\n  };\n  /**\n   * Check if a value from this record, either by index or by field key, exists.\n   *\n   * @param {string|Number} key Field key, or the index of the field.\n   * @returns {boolean}\n   */\n  Record.prototype.has = function (key) {\n    // if key is a number, we check if it is in the _fields array\n    if (typeof key === 'number') {\n      return key >= 0 && key < this._fields.length;\n    }\n    // if it's not a number, we check _fieldLookup dictionary directly\n    return this._fieldLookup[key] !== undefined;\n  };\n  return Record;\n}();\nexports.default = Record;","map":null,"metadata":{},"sourceType":"script"}