{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar bolt_protocol_v1_1 = __importDefault(require(\"./bolt-protocol-v1\"));\nvar bolt_protocol_v2_1 = __importDefault(require(\"./bolt-protocol-v2\"));\nvar bolt_protocol_v3_1 = __importDefault(require(\"./bolt-protocol-v3\"));\nvar bolt_protocol_v4x0_1 = __importDefault(require(\"./bolt-protocol-v4x0\"));\nvar bolt_protocol_v4x1_1 = __importDefault(require(\"./bolt-protocol-v4x1\"));\nvar bolt_protocol_v4x2_1 = __importDefault(require(\"./bolt-protocol-v4x2\"));\nvar bolt_protocol_v4x3_1 = __importDefault(require(\"./bolt-protocol-v4x3\"));\nvar bolt_protocol_v4x4_1 = __importDefault(require(\"./bolt-protocol-v4x4\"));\nvar response_handler_1 = __importDefault(require(\"./response-handler\"));\n/**\n * Creates a protocol with a given version\n *\n * @param {object} config\n * @param {number} config.version The version of the protocol\n * @param {channel} config.channel The channel\n * @param {Chunker} config.chunker The chunker\n * @param {Dechunker} config.dechunker The dechunker\n * @param {Logger} config.log The logger\n * @param {ResponseHandler~Observer} config.observer Observer\n * @param {boolean} config.disableLosslessIntegers Disable the lossless integers\n * @param {boolean} packstreamConfig.useBigInt if this connection should convert all received integers to native BigInt numbers.\n * @param {boolean} config.serversideRouting It's using server side routing\n */\nfunction create(_a) {\n  var _b = _a === void 0 ? {} : _a,\n    version = _b.version,\n    chunker = _b.chunker,\n    dechunker = _b.dechunker,\n    channel = _b.channel,\n    disableLosslessIntegers = _b.disableLosslessIntegers,\n    useBigInt = _b.useBigInt,\n    serversideRouting = _b.serversideRouting,\n    server = _b.server,\n    // server info\n    log = _b.log,\n    observer = _b.observer;\n  var createResponseHandler = function createResponseHandler(protocol) {\n    var responseHandler = new response_handler_1.default({\n      transformMetadata: protocol.transformMetadata.bind(protocol),\n      log: log,\n      observer: observer\n    });\n    // reset the error handler to just handle errors and forget about the handshake promise\n    channel.onerror = observer.onError.bind(observer);\n    // Ok, protocol running. Simply forward all messages to the dechunker\n    channel.onmessage = function (buf) {\n      return dechunker.write(buf);\n    };\n    // setup dechunker to dechunk messages and forward them to the message handler\n    dechunker.onmessage = function (buf) {\n      try {\n        responseHandler.handleResponse(protocol.unpacker().unpack(buf));\n      } catch (e) {\n        return observer.onError(e);\n      }\n    };\n    return responseHandler;\n  };\n  return createProtocol(version, server, chunker, {\n    disableLosslessIntegers: disableLosslessIntegers,\n    useBigInt: useBigInt\n  }, serversideRouting, createResponseHandler, observer.onProtocolError.bind(observer), log);\n}\nexports.default = create;\nfunction createProtocol(version, server, chunker, packingConfig, serversideRouting, createResponseHandler, onProtocolError, log) {\n  switch (version) {\n    case 1:\n      return new bolt_protocol_v1_1.default(server, chunker, packingConfig, createResponseHandler, log, onProtocolError);\n    case 2:\n      return new bolt_protocol_v2_1.default(server, chunker, packingConfig, createResponseHandler, log, onProtocolError);\n    case 3:\n      return new bolt_protocol_v3_1.default(server, chunker, packingConfig, createResponseHandler, log, onProtocolError);\n    case 4.0:\n      return new bolt_protocol_v4x0_1.default(server, chunker, packingConfig, createResponseHandler, log, onProtocolError);\n    case 4.1:\n      return new bolt_protocol_v4x1_1.default(server, chunker, packingConfig, createResponseHandler, log, onProtocolError, serversideRouting);\n    case 4.2:\n      return new bolt_protocol_v4x2_1.default(server, chunker, packingConfig, createResponseHandler, log, onProtocolError, serversideRouting);\n    case 4.3:\n      return new bolt_protocol_v4x3_1.default(server, chunker, packingConfig, createResponseHandler, log, onProtocolError, serversideRouting);\n    case 4.4:\n      return new bolt_protocol_v4x4_1.default(server, chunker, packingConfig, createResponseHandler, log, onProtocolError, serversideRouting);\n    default:\n      throw (0, neo4j_driver_core_1.newError)('Unknown Bolt protocol version: ' + version);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}