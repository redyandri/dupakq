{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dechunker = exports.Chunker = void 0;\nvar base_buf_1 = __importDefault(require(\"../buf/base-buf\"));\nvar channel_buf_1 = require(\"./channel-buf\");\nvar combined_buf_1 = __importDefault(require(\"./combined-buf\"));\nvar _CHUNK_HEADER_SIZE = 2;\nvar _MESSAGE_BOUNDARY = 0x00;\nvar _DEFAULT_BUFFER_SIZE = 1400; // http://stackoverflow.com/questions/2613734/maximum-packet-size-for-a-tcp-connection\n/**\n * Looks like a writable buffer, chunks output transparently into a channel below.\n * @access private\n */\nvar Chunker = /** @class */function (_super) {\n  __extends(Chunker, _super);\n  function Chunker(channel, bufferSize) {\n    var _this = _super.call(this, 0) || this;\n    _this._bufferSize = bufferSize || _DEFAULT_BUFFER_SIZE;\n    _this._ch = channel;\n    _this._buffer = (0, channel_buf_1.alloc)(_this._bufferSize);\n    _this._currentChunkStart = 0;\n    _this._chunkOpen = false;\n    return _this;\n  }\n  Chunker.prototype.putUInt8 = function (position, val) {\n    this._ensure(1);\n    this._buffer.writeUInt8(val);\n  };\n  Chunker.prototype.putInt8 = function (position, val) {\n    this._ensure(1);\n    this._buffer.writeInt8(val);\n  };\n  Chunker.prototype.putFloat64 = function (position, val) {\n    this._ensure(8);\n    this._buffer.writeFloat64(val);\n  };\n  Chunker.prototype.putBytes = function (position, data) {\n    // TODO: If data is larger than our chunk size or so, we're very likely better off just passing this buffer on\n    // rather than doing the copy here TODO: *however* note that we need some way to find out when the data has been\n    // written (and thus the buffer can be re-used) if we take that approach\n    while (data.remaining() > 0) {\n      // Ensure there is an open chunk, and that it has at least one byte of space left\n      this._ensure(1);\n      if (this._buffer.remaining() > data.remaining()) {\n        this._buffer.writeBytes(data);\n      } else {\n        this._buffer.writeBytes(data.readSlice(this._buffer.remaining()));\n      }\n    }\n    return this;\n  };\n  Chunker.prototype.flush = function () {\n    if (this._buffer.position > 0) {\n      this._closeChunkIfOpen();\n      // Local copy and clear the buffer field. This ensures that the buffer is not re-released if the flush call fails\n      var out = this._buffer;\n      this._buffer = null;\n      this._ch.write(out.getSlice(0, out.position));\n      // Alloc a new output buffer. We assume we're using NodeJS's buffer pooling under the hood here!\n      this._buffer = (0, channel_buf_1.alloc)(this._bufferSize);\n      this._chunkOpen = false;\n    }\n    return this;\n  };\n  /**\n   * Bolt messages are encoded in one or more chunks, and the boundary between two messages\n   * is encoded as a 0-length chunk, `00 00`. This inserts such a message boundary, closing\n   * any currently open chunk as needed\n   */\n  Chunker.prototype.messageBoundary = function () {\n    this._closeChunkIfOpen();\n    if (this._buffer.remaining() < _CHUNK_HEADER_SIZE) {\n      this.flush();\n    }\n    // Write message boundary\n    this._buffer.writeInt16(_MESSAGE_BOUNDARY);\n  };\n  /** Ensure at least the given size is available for writing */\n  Chunker.prototype._ensure = function (size) {\n    var toWriteSize = this._chunkOpen ? size : size + _CHUNK_HEADER_SIZE;\n    if (this._buffer.remaining() < toWriteSize) {\n      this.flush();\n    }\n    if (!this._chunkOpen) {\n      this._currentChunkStart = this._buffer.position;\n      this._buffer.position = this._buffer.position + _CHUNK_HEADER_SIZE;\n      this._chunkOpen = true;\n    }\n  };\n  Chunker.prototype._closeChunkIfOpen = function () {\n    if (this._chunkOpen) {\n      var chunkSize = this._buffer.position - (this._currentChunkStart + _CHUNK_HEADER_SIZE);\n      this._buffer.putUInt16(this._currentChunkStart, chunkSize);\n      this._chunkOpen = false;\n    }\n  };\n  return Chunker;\n}(base_buf_1.default);\nexports.Chunker = Chunker;\n/**\n * Combines chunks until a complete message is gathered up, and then forwards that\n * message to an 'onmessage' listener.\n * @access private\n */\nvar Dechunker = /** @class */function () {\n  function Dechunker() {\n    this._currentMessage = [];\n    this._partialChunkHeader = 0;\n    this._state = this.AWAITING_CHUNK;\n  }\n  Dechunker.prototype.AWAITING_CHUNK = function (buf) {\n    if (buf.remaining() >= 2) {\n      // Whole header available, read that\n      return this._onHeader(buf.readUInt16());\n    } else {\n      // Only one byte available, read that and wait for the second byte\n      this._partialChunkHeader = buf.readUInt8() << 8;\n      return this.IN_HEADER;\n    }\n  };\n  Dechunker.prototype.IN_HEADER = function (buf) {\n    // First header byte read, now we read the next one\n    return this._onHeader((this._partialChunkHeader | buf.readUInt8()) & 0xffff);\n  };\n  Dechunker.prototype.IN_CHUNK = function (buf) {\n    if (this._chunkSize <= buf.remaining()) {\n      // Current packet is larger than current chunk, or same size:\n      this._currentMessage.push(buf.readSlice(this._chunkSize));\n      return this.AWAITING_CHUNK;\n    } else {\n      // Current packet is smaller than the chunk we're reading, split the current chunk itself up\n      this._chunkSize -= buf.remaining();\n      this._currentMessage.push(buf.readSlice(buf.remaining()));\n      return this.IN_CHUNK;\n    }\n  };\n  Dechunker.prototype.CLOSED = function (buf) {\n    // no-op\n  };\n  /** Called when a complete chunk header has been received */\n  Dechunker.prototype._onHeader = function (header) {\n    if (header === 0) {\n      // Message boundary\n      var message = void 0;\n      switch (this._currentMessage.length) {\n        case 0:\n          // Keep alive chunk, sent by server to keep network alive.\n          return this.AWAITING_CHUNK;\n        case 1:\n          // All data in one chunk, this signals the end of that chunk.\n          message = this._currentMessage[0];\n          break;\n        default:\n          // A large chunk of data received, this signals that the last chunk has been received.\n          message = new combined_buf_1.default(this._currentMessage);\n          break;\n      }\n      this._currentMessage = [];\n      this.onmessage(message);\n      return this.AWAITING_CHUNK;\n    } else {\n      this._chunkSize = header;\n      return this.IN_CHUNK;\n    }\n  };\n  Dechunker.prototype.write = function (buf) {\n    while (buf.hasRemaining()) {\n      this._state = this._state(buf);\n    }\n  };\n  return Dechunker;\n}();\nexports.Dechunker = Dechunker;","map":null,"metadata":{},"sourceType":"script"}