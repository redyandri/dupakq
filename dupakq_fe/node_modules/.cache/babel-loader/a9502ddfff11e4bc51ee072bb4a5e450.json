{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar channel_buf_1 = __importDefault(require(\"../channel-buf\"));\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar _a = neo4j_driver_core_1.internal.util,\n  ENCRYPTION_OFF = _a.ENCRYPTION_OFF,\n  ENCRYPTION_ON = _a.ENCRYPTION_ON;\n// Just to be sure that these values are with us even after WebSocket is injected\n// for tests.\nvar WS_CONNECTING = 0;\nvar WS_OPEN = 1;\nvar WS_CLOSING = 2;\nvar WS_CLOSED = 3;\n/**\n * Create a new WebSocketChannel to be used in web browsers.\n * @access private\n */\nvar WebSocketChannel = /** @class */function () {\n  /**\n   * Create new instance\n   * @param {ChannelConfig} config - configuration for this channel.\n   * @param {function(): string} protocolSupplier - function that detects protocol of the web page. Should only be used in tests.\n   */\n  function WebSocketChannel(config, protocolSupplier, socketFactory) {\n    if (protocolSupplier === void 0) {\n      protocolSupplier = detectWebPageProtocol;\n    }\n    if (socketFactory === void 0) {\n      socketFactory = function socketFactory(url) {\n        return new WebSocket(url);\n      };\n    }\n    this._open = true;\n    this._pending = [];\n    this._error = null;\n    this._handleConnectionError = this._handleConnectionError.bind(this);\n    this._config = config;\n    var _a = determineWebSocketScheme(config, protocolSupplier),\n      scheme = _a.scheme,\n      error = _a.error;\n    if (error) {\n      this._error = error;\n      return;\n    }\n    this._ws = createWebSocket(scheme, config.address, socketFactory);\n    this._ws.binaryType = 'arraybuffer';\n    var self = this;\n    // All connection errors are not sent to the error handler\n    // we must also check for dirty close calls\n    this._ws.onclose = function (e) {\n      if (e && !e.wasClean) {\n        self._handleConnectionError();\n      }\n      self._open = false;\n    };\n    this._ws.onopen = function () {\n      // Connected! Cancel the connection timeout\n      self._clearConnectionTimeout();\n      // Drain all pending messages\n      var pending = self._pending;\n      self._pending = null;\n      for (var i = 0; i < pending.length; i++) {\n        self.write(pending[i]);\n      }\n    };\n    this._ws.onmessage = function (event) {\n      if (self.onmessage) {\n        var b = new channel_buf_1.default(event.data);\n        self.onmessage(b);\n      }\n    };\n    this._ws.onerror = this._handleConnectionError;\n    this._connectionTimeoutFired = false;\n    this._connectionTimeoutId = this._setupConnectionTimeout();\n  }\n  WebSocketChannel.prototype._handleConnectionError = function () {\n    if (this._connectionTimeoutFired) {\n      // timeout fired - not connected within configured time\n      this._error = (0, neo4j_driver_core_1.newError)(\"Failed to establish connection in \" + this._config.connectionTimeout + \"ms\", this._config.connectionErrorCode);\n      if (this.onerror) {\n        this.onerror(this._error);\n      }\n      return;\n    }\n    // onerror triggers on websocket close as well.. don't get me started.\n    if (this._open) {\n      // http://stackoverflow.com/questions/25779831/how-to-catch-websocket-connection-to-ws-xxxnn-failed-connection-closed-be\n      this._error = (0, neo4j_driver_core_1.newError)('WebSocket connection failure. Due to security ' + 'constraints in your web browser, the reason for the failure is not available ' + 'to this Neo4j Driver. Please use your browsers development console to determine ' + 'the root cause of the failure. Common reasons include the database being ' + 'unavailable, using the wrong connection URL or temporary network problems. ' + 'If you have enabled encryption, ensure your browser is configured to trust the ' + 'certificate Neo4j is configured to use. WebSocket `readyState` is: ' + this._ws.readyState, this._config.connectionErrorCode);\n      if (this.onerror) {\n        this.onerror(this._error);\n      }\n    }\n  };\n  /**\n   * Write the passed in buffer to connection\n   * @param {ChannelBuffer} buffer - Buffer to write\n   */\n  WebSocketChannel.prototype.write = function (buffer) {\n    // If there is a pending queue, push this on that queue. This means\n    // we are not yet connected, so we queue things locally.\n    if (this._pending !== null) {\n      this._pending.push(buffer);\n    } else if (buffer instanceof channel_buf_1.default) {\n      try {\n        this._ws.send(buffer._buffer);\n      } catch (error) {\n        if (this._ws.readyState !== WS_OPEN) {\n          // Websocket has been closed\n          this._handleConnectionError();\n        } else {\n          // Some other error occured\n          throw error;\n        }\n      }\n    } else {\n      throw (0, neo4j_driver_core_1.newError)(\"Don't know how to send buffer: \" + buffer);\n    }\n  };\n  /**\n   * Close the connection\n   * @returns {Promise} A promise that will be resolved after channel is closed\n   */\n  WebSocketChannel.prototype.close = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (_this._ws && _this._ws.readyState !== WS_CLOSED) {\n        _this._open = false;\n        _this._clearConnectionTimeout();\n        _this._ws.onclose = function () {\n          return resolve();\n        };\n        _this._ws.close();\n      } else {\n        resolve();\n      }\n    });\n  };\n  /**\n   * Setup the receive timeout for the channel.\n   *\n   * Not supported for the browser channel.\n   *\n   * @param {number} receiveTimeout The amount of time the channel will keep without receive any data before timeout (ms)\n   * @returns {void}\n   */\n  WebSocketChannel.prototype.setupReceiveTimeout = function (receiveTimeout) {};\n  /**\n   * Stops the receive timeout for the channel.\n   */\n  WebSocketChannel.prototype.stopReceiveTimeout = function () {};\n  /**\n   * Start the receive timeout for the channel.\n   */\n  WebSocketChannel.prototype.startReceiveTimeout = function () {};\n  /**\n   * Set connection timeout on the given WebSocket, if configured.\n   * @return {number} the timeout id or null.\n   * @private\n   */\n  WebSocketChannel.prototype._setupConnectionTimeout = function () {\n    var _this = this;\n    var timeout = this._config.connectionTimeout;\n    if (timeout) {\n      var webSocket_1 = this._ws;\n      return setTimeout(function () {\n        if (webSocket_1.readyState !== WS_OPEN) {\n          _this._connectionTimeoutFired = true;\n          webSocket_1.close();\n        }\n      }, timeout);\n    }\n    return null;\n  };\n  /**\n   * Remove active connection timeout, if any.\n   * @private\n   */\n  WebSocketChannel.prototype._clearConnectionTimeout = function () {\n    var timeoutId = this._connectionTimeoutId;\n    if (timeoutId || timeoutId === 0) {\n      this._connectionTimeoutFired = false;\n      this._connectionTimeoutId = null;\n      clearTimeout(timeoutId);\n    }\n  };\n  return WebSocketChannel;\n}();\nexports.default = WebSocketChannel;\nfunction createWebSocket(scheme, address, socketFactory) {\n  var url = scheme + '://' + address.asHostPort();\n  try {\n    return socketFactory(url);\n  } catch (error) {\n    if (isIPv6AddressIssueOnWindows(error, address)) {\n      // WebSocket in IE and Edge browsers on Windows do not support regular IPv6 address syntax because they contain ':'.\n      // It's an invalid character for UNC (https://en.wikipedia.org/wiki/IPv6_address#Literal_IPv6_addresses_in_UNC_path_names)\n      // and Windows requires IPv6 to be changes in the following way:\n      //   1) replace all ':' with '-'\n      //   2) replace '%' with 's' for link-local address\n      //   3) append '.ipv6-literal.net' suffix\n      // only then resulting string can be considered a valid IPv6 address. Yes, this is extremely weird!\n      // For more details see:\n      //   https://social.msdn.microsoft.com/Forums/ie/en-US/06cca73b-63c2-4bf9-899b-b229c50449ff/whether-ie10-websocket-support-ipv6?forum=iewebdevelopment\n      //   https://www.itdojo.com/ipv6-addresses-and-unc-path-names-overcoming-illegal/\n      // Creation of WebSocket with unconverted address results in SyntaxError without message or stacktrace.\n      // That is why here we \"catch\" SyntaxError and rewrite IPv6 address if needed.\n      var windowsFriendlyUrl = asWindowsFriendlyIPv6Address(scheme, address);\n      return socketFactory(windowsFriendlyUrl);\n    } else {\n      throw error;\n    }\n  }\n}\nfunction isIPv6AddressIssueOnWindows(error, address) {\n  return error.name === 'SyntaxError' && isIPv6Address(address.asHostPort());\n}\nfunction isIPv6Address(hostAndPort) {\n  return hostAndPort.charAt(0) === '[' && hostAndPort.indexOf(']') !== -1;\n}\nfunction asWindowsFriendlyIPv6Address(scheme, address) {\n  // replace all ':' with '-'\n  var hostWithoutColons = address.host().replace(new RegExp(':', 'g'), '-');\n  // replace '%' with 's' for link-local IPv6 address like 'fe80::1%lo0'\n  var hostWithoutPercent = hostWithoutColons.replace('%', 's');\n  // append magic '.ipv6-literal.net' suffix\n  var ipv6Host = hostWithoutPercent + '.ipv6-literal.net';\n  return scheme + \"://\" + ipv6Host + \":\" + address.port();\n}\n/**\n * @param {ChannelConfig} config - configuration for the channel.\n * @param {function(): string} protocolSupplier - function that detects protocol of the web page.\n * @return {{scheme: string|null, error: Neo4jError|null}} object containing either scheme or error.\n */\nfunction determineWebSocketScheme(config, protocolSupplier) {\n  var encryptionOn = isEncryptionExplicitlyTurnedOn(config);\n  var encryptionOff = isEncryptionExplicitlyTurnedOff(config);\n  var trust = config.trust;\n  var secureProtocol = isProtocolSecure(protocolSupplier);\n  verifyEncryptionSettings(encryptionOn, encryptionOff, secureProtocol);\n  if (encryptionOff) {\n    // encryption explicitly turned off in the config\n    return {\n      scheme: 'ws',\n      error: null\n    };\n  }\n  if (secureProtocol) {\n    // driver is used in a secure https web page, use 'wss'\n    return {\n      scheme: 'wss',\n      error: null\n    };\n  }\n  if (encryptionOn) {\n    // encryption explicitly requested in the config\n    if (!trust || trust === 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES') {\n      // trust strategy not specified or the only supported strategy is specified\n      return {\n        scheme: 'wss',\n        error: null\n      };\n    } else {\n      var error = (0, neo4j_driver_core_1.newError)('The browser version of this driver only supports one trust ' + \"strategy, 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES'. \" + trust + ' is not supported. Please ' + 'either use TRUST_SYSTEM_CA_SIGNED_CERTIFICATES or disable encryption by setting ' + '`encrypted:\"' + ENCRYPTION_OFF + '\"` in the driver configuration.');\n      return {\n        scheme: null,\n        error: error\n      };\n    }\n  }\n  // default to unencrypted web socket\n  return {\n    scheme: 'ws',\n    error: null\n  };\n}\n/**\n * @param {ChannelConfig} config - configuration for the channel.\n * @return {boolean} `true` if encryption enabled in the config, `false` otherwise.\n */\nfunction isEncryptionExplicitlyTurnedOn(config) {\n  return config.encrypted === true || config.encrypted === ENCRYPTION_ON;\n}\n/**\n * @param {ChannelConfig} config - configuration for the channel.\n * @return {boolean} `true` if encryption disabled in the config, `false` otherwise.\n */\nfunction isEncryptionExplicitlyTurnedOff(config) {\n  return config.encrypted === false || config.encrypted === ENCRYPTION_OFF;\n}\n/**\n * @param {function(): string} protocolSupplier - function that detects protocol of the web page.\n * @return {boolean} `true` if protocol returned by the given function is secure, `false` otherwise.\n */\nfunction isProtocolSecure(protocolSupplier) {\n  var protocol = typeof protocolSupplier === 'function' ? protocolSupplier() : '';\n  return protocol && protocol.toLowerCase().indexOf('https') >= 0;\n}\nfunction verifyEncryptionSettings(encryptionOn, encryptionOff, secureProtocol) {\n  if (secureProtocol === null) {\n    // do nothing sice the protocol could not be identified\n  } else if (encryptionOn && !secureProtocol) {\n    // encryption explicitly turned on for a driver used on a HTTP web page\n    console.warn('Neo4j driver is configured to use secure WebSocket on a HTTP web page. ' + 'WebSockets might not work in a mixed content environment. ' + 'Please consider configuring driver to not use encryption.');\n  } else if (encryptionOff && secureProtocol) {\n    // encryption explicitly turned off for a driver used on a HTTPS web page\n    console.warn('Neo4j driver is configured to use insecure WebSocket on a HTTPS web page. ' + 'WebSockets might not work in a mixed content environment. ' + 'Please consider configuring driver to use encryption.');\n  }\n}\nfunction detectWebPageProtocol() {\n  return typeof window !== 'undefined' && window.location ? window.location.protocol : null;\n}","map":null,"metadata":{},"sourceType":"script"}