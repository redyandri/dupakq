{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n// Signature bytes for each response message type\nvar SUCCESS = 0x70; // 0111 0000 // SUCCESS <metadata>\nvar RECORD = 0x71; // 0111 0001 // RECORD <value>\nvar IGNORED = 0x7e; // 0111 1110 // IGNORED <metadata>\nvar FAILURE = 0x7f; // 0111 1111 // FAILURE <metadata>\nfunction NO_OP() {}\nfunction NO_OP_IDENTITY(subject) {\n  return subject;\n}\nvar NO_OP_OBSERVER = {\n  onNext: NO_OP,\n  onCompleted: NO_OP,\n  onError: NO_OP\n};\n/**\n * Treat the protocol responses and notify the observers\n */\nvar ResponseHandler = /** @class */function () {\n  /**\n   * Called when something went wrong with the connectio\n   * @callback ResponseHandler~Observer~OnErrorApplyTransformation\n   * @param {any} error The error\n   * @returns {any} The new error\n   */\n  /**\n   * Called when something went wrong with the connectio\n   * @callback ResponseHandler~Observer~OnError\n   * @param {any} error The error\n   */\n  /**\n   * Called when something went wrong with the connectio\n   * @callback ResponseHandler~MetadataTransformer\n   * @param {any} metadata The metadata got onSuccess\n   * @returns {any} The transformed metadata\n   */\n  /**\n   * @typedef {Object} ResponseHandler~Observer\n   * @property {ResponseHandler~Observer~OnError} onError Invoke when a connection error occurs\n   * @property {ResponseHandler~Observer~OnError} onFailure Invoke when a protocol failure occurs\n   * @property {ResponseHandler~Observer~OnErrorApplyTransformation} onErrorApplyTransformation Invoke just after the failure occurs,\n   *  before notify to respective observer. This method should transform the failure reason to the approprited one.\n   */\n  /**\n   * Constructor\n   * @param {Object} param The params\n   * @param {ResponseHandler~MetadataTransformer} transformMetadata Transform metadata when the SUCCESS is received.\n   * @param {Channel} channel The channel used to exchange messages\n   * @param {Logger} log The logger\n   * @param {ResponseHandler~Observer} observer Object which will be notified about errors\n   */\n  function ResponseHandler(_a) {\n    var _b = _a === void 0 ? {} : _a,\n      transformMetadata = _b.transformMetadata,\n      log = _b.log,\n      observer = _b.observer;\n    this._pendingObservers = [];\n    this._log = log;\n    this._transformMetadata = transformMetadata || NO_OP_IDENTITY;\n    this._observer = Object.assign({\n      onPendingObserversChange: NO_OP,\n      onError: NO_OP,\n      onFailure: NO_OP,\n      onErrorApplyTransformation: NO_OP_IDENTITY\n    }, observer);\n  }\n  Object.defineProperty(ResponseHandler.prototype, \"currentFailure\", {\n    get: function get() {\n      return this._currentFailure;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ResponseHandler.prototype.handleResponse = function (msg) {\n    var payload = msg.fields[0];\n    switch (msg.signature) {\n      case RECORD:\n        if (this._log.isDebugEnabled()) {\n          this._log.debug(\"S: RECORD \" + neo4j_driver_core_1.json.stringify(msg));\n        }\n        this._currentObserver.onNext(payload);\n        break;\n      case SUCCESS:\n        if (this._log.isDebugEnabled()) {\n          this._log.debug(\"S: SUCCESS \" + neo4j_driver_core_1.json.stringify(msg));\n        }\n        try {\n          var metadata = this._transformMetadata(payload);\n          this._currentObserver.onCompleted(metadata);\n        } finally {\n          this._updateCurrentObserver();\n        }\n        break;\n      case FAILURE:\n        if (this._log.isDebugEnabled()) {\n          this._log.debug(\"S: FAILURE \" + neo4j_driver_core_1.json.stringify(msg));\n        }\n        try {\n          var error = (0, neo4j_driver_core_1.newError)(payload.message, payload.code);\n          this._currentFailure = this._observer.onErrorApplyTransformation(error);\n          this._currentObserver.onError(this._currentFailure);\n        } finally {\n          this._updateCurrentObserver();\n          // Things are now broken. Pending observers will get FAILURE messages routed until we are done handling this failure.\n          this._observer.onFailure(this._currentFailure);\n        }\n        break;\n      case IGNORED:\n        if (this._log.isDebugEnabled()) {\n          this._log.debug(\"S: IGNORED \" + neo4j_driver_core_1.json.stringify(msg));\n        }\n        try {\n          if (this._currentFailure && this._currentObserver.onError) {\n            this._currentObserver.onError(this._currentFailure);\n          } else if (this._currentObserver.onError) {\n            this._currentObserver.onError((0, neo4j_driver_core_1.newError)('Ignored either because of an error or RESET'));\n          }\n        } finally {\n          this._updateCurrentObserver();\n        }\n        break;\n      default:\n        this._observer.onError((0, neo4j_driver_core_1.newError)('Unknown Bolt protocol message: ' + msg));\n    }\n  };\n  /*\n   * Pop next pending observer form the list of observers and make it current observer.\n   * @protected\n   */\n  ResponseHandler.prototype._updateCurrentObserver = function () {\n    this._currentObserver = this._pendingObservers.shift();\n    this._observer.onPendingObserversChange(this._pendingObservers.length);\n  };\n  ResponseHandler.prototype._queueObserver = function (observer) {\n    observer = observer || NO_OP_OBSERVER;\n    observer.onCompleted = observer.onCompleted || NO_OP;\n    observer.onError = observer.onError || NO_OP;\n    observer.onNext = observer.onNext || NO_OP;\n    if (this._currentObserver === undefined) {\n      this._currentObserver = observer;\n    } else {\n      this._pendingObservers.push(observer);\n    }\n    this._observer.onPendingObserversChange(this._pendingObservers.length);\n    return true;\n  };\n  ResponseHandler.prototype._notifyErrorToObservers = function (error) {\n    if (this._currentObserver && this._currentObserver.onError) {\n      this._currentObserver.onError(error);\n    }\n    while (this._pendingObservers.length > 0) {\n      var observer = this._pendingObservers.shift();\n      if (observer && observer.onError) {\n        observer.onError(error);\n      }\n    }\n  };\n  ResponseHandler.prototype.hasOngoingObservableRequests = function () {\n    return this._currentObserver != null || this._pendingObservers.length > 0;\n  };\n  ResponseHandler.prototype._resetFailure = function () {\n    this._currentFailure = null;\n  };\n  return ResponseHandler;\n}();\nexports.default = ResponseHandler;","map":null,"metadata":{},"sourceType":"script"}