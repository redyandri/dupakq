{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isPathSegment = exports.PathSegment = exports.isPath = exports.Path = exports.isUnboundRelationship = exports.UnboundRelationship = exports.isRelationship = exports.Relationship = exports.isNode = exports.Node = void 0;\nvar json_1 = require(\"./json\");\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n  value: true,\n  enumerable: false,\n  configurable: false,\n  writable: false\n};\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\nfunction hasIdentifierProperty(obj, property) {\n  return (obj && obj[property]) === true;\n}\n/**\n * Class for Node Type.\n */\nvar Node = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Integer|number} identity - Unique identity\n   * @param {Array<string>} labels - Array for all labels\n   * @param {Properties} properties - Map with node properties\n   */\n  function Node(identity, labels, properties) {\n    /**\n     * Identity of the node.\n     * @type {Integer|number}\n     */\n    this.identity = identity;\n    /**\n     * Labels of the node.\n     * @type {string[]}\n     */\n    this.labels = labels;\n    /**\n     * Properties of the node.\n     * @type {Properties}\n     */\n    this.properties = properties;\n  }\n  /**\n   * @ignore\n   */\n  Node.prototype.toString = function () {\n    var s = '(' + this.identity;\n    for (var i = 0; i < this.labels.length; i++) {\n      s += ':' + this.labels[i];\n    }\n    var keys = Object.keys(this.properties);\n    if (keys.length > 0) {\n      s += ' {';\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n      s += '}';\n    }\n    s += ')';\n    return s;\n  };\n  return Node;\n}();\nexports.Node = Node;\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Node} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\n */\nfunction isNode(obj) {\n  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\n}\nexports.isNode = isNode;\n/**\n * Class for Relationship Type.\n */\nvar Relationship = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Integer|number} identity - Unique identity\n   * @param {Integer|number} start - Identity of start Node\n   * @param {Integer|number} end - Identity of end Node\n   * @param {string} type - Relationship type\n   * @param {Properties} properties - Map with relationship properties\n   */\n  function Relationship(identity, start, end, type, properties) {\n    /**\n     * Identity of the relationship.\n     * @type {Integer|number}\n     */\n    this.identity = identity;\n    /**\n     * Identity of the start node.\n     * @type {Integer|number}\n     */\n    this.start = start;\n    /**\n     * Identity of the end node.\n     * @type {Integer|number}\n     */\n    this.end = end;\n    /**\n     * Type of the relationship.\n     * @type {string}\n     */\n    this.type = type;\n    /**\n     * Properties of the relationship.\n     * @type {Properties}\n     */\n    this.properties = properties;\n  }\n  /**\n   * @ignore\n   */\n  Relationship.prototype.toString = function () {\n    var s = '(' + this.start + ')-[:' + this.type;\n    var keys = Object.keys(this.properties);\n    if (keys.length > 0) {\n      s += ' {';\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n      s += '}';\n    }\n    s += ']->(' + this.end + ')';\n    return s;\n  };\n  return Relationship;\n}();\nexports.Relationship = Relationship;\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Relationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\n */\nfunction isRelationship(obj) {\n  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\nexports.isRelationship = isRelationship;\n/**\n * Class for UnboundRelationship Type.\n * @access private\n */\nvar UnboundRelationship = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Integer|number} identity - Unique identity\n   * @param {string} type - Relationship type\n   * @param {Properties} properties - Map with relationship properties\n   */\n  function UnboundRelationship(identity, type, properties) {\n    /**\n     * Identity of the relationship.\n     * @type {Integer|number}\n     */\n    this.identity = identity;\n    /**\n     * Type of the relationship.\n     * @type {string}\n     */\n    this.type = type;\n    /**\n     * Properties of the relationship.\n     * @type {Properties}\n     */\n    this.properties = properties;\n  }\n  /**\n   * Bind relationship\n   *\n   * @protected\n   * @param {Integer} start - Identity of start node\n   * @param {Integer} end - Identity of end node\n   * @return {Relationship} - Created relationship\n   */\n  UnboundRelationship.prototype.bind = function (start, end) {\n    return new Relationship(this.identity, start, end, this.type, this.properties);\n  };\n  /**\n   * @ignore\n   */\n  UnboundRelationship.prototype.toString = function () {\n    var s = '-[:' + this.type;\n    var keys = Object.keys(this.properties);\n    if (keys.length > 0) {\n      s += ' {';\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n      s += '}';\n    }\n    s += ']->';\n    return s;\n  };\n  return UnboundRelationship;\n}();\nexports.UnboundRelationship = UnboundRelationship;\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link UnboundRelationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\n */\nfunction isUnboundRelationship(obj) {\n  return hasIdentifierProperty(obj, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\nexports.isUnboundRelationship = isUnboundRelationship;\n/**\n * Class for PathSegment Type.\n */\nvar PathSegment = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Node} start - start node\n   * @param {Relationship} rel - relationship that connects start and end node\n   * @param {Node} end - end node\n   */\n  function PathSegment(start, rel, end) {\n    /**\n     * Start node.\n     * @type {Node}\n     */\n    this.start = start;\n    /**\n     * Relationship.\n     * @type {Relationship}\n     */\n    this.relationship = rel;\n    /**\n     * End node.\n     * @type {Node}\n     */\n    this.end = end;\n  }\n  return PathSegment;\n}();\nexports.PathSegment = PathSegment;\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link PathSegment} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\n */\nfunction isPathSegment(obj) {\n  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\n}\nexports.isPathSegment = isPathSegment;\n/**\n * Class for Path Type.\n */\nvar Path = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Node} start  - start node\n   * @param {Node} end - end node\n   * @param {Array<PathSegment>} segments - Array of Segments\n   */\n  function Path(start, end, segments) {\n    /**\n     * Start node.\n     * @type {Node}\n     */\n    this.start = start;\n    /**\n     * End node.\n     * @type {Node}\n     */\n    this.end = end;\n    /**\n     * Segments.\n     * @type {Array<PathSegment>}\n     */\n    this.segments = segments;\n    /**\n     * Length of the segments.\n     * @type {Number}\n     */\n    this.length = segments.length;\n  }\n  return Path;\n}();\nexports.Path = Path;\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Path} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\n */\nfunction isPath(obj) {\n  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\n}\nexports.isPath = isPath;","map":null,"metadata":{},"sourceType":"script"}