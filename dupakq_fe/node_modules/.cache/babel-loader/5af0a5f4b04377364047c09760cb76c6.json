{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Url = exports.formatIPv6Address = exports.formatIPv4Address = exports.defaultPortForScheme = exports.parseDatabaseUrl = void 0;\nvar util_1 = require(\"./util\");\nvar DEFAULT_BOLT_PORT = 7687;\nvar DEFAULT_HTTP_PORT = 7474;\nvar DEFAULT_HTTPS_PORT = 7473;\nvar Url = /** @class */function () {\n  function Url(scheme, host, port, hostAndPort, query) {\n    /**\n     * Nullable scheme (protocol) of the URL.\n     * Example: 'bolt', 'neo4j', 'http', 'https', etc.\n     * @type {string}\n     */\n    this.scheme = scheme;\n    /**\n     * Nonnull host name or IP address. IPv6 not wrapped in square brackets.\n     * Example: 'neo4j.com', 'localhost', '127.0.0.1', '192.168.10.15', '::1', '2001:4860:4860::8844', etc.\n     * @type {string}\n     */\n    this.host = host;\n    /**\n     * Nonnull number representing port. Default port for the given scheme is used if given URL string\n     * does not contain port. Example: 7687 for bolt, 7474 for HTTP and 7473 for HTTPS.\n     * @type {number}\n     */\n    this.port = port;\n    /**\n     * Nonnull host name or IP address plus port, separated by ':'. IPv6 wrapped in square brackets.\n     * Example: 'neo4j.com', 'neo4j.com:7687', '127.0.0.1', '127.0.0.1:8080', '[2001:4860:4860::8844]',\n     * '[2001:4860:4860::8844]:9090', etc.\n     * @type {string}\n     */\n    this.hostAndPort = hostAndPort;\n    /**\n     * Nonnull object representing parsed query string key-value pairs. Duplicated keys not supported.\n     * Example: '{}', '{'key1': 'value1', 'key2': 'value2'}', etc.\n     * @type {Object}\n     */\n    this.query = query;\n  }\n  return Url;\n}();\nexports.Url = Url;\nfunction parseDatabaseUrl(url) {\n  (0, util_1.assertString)(url, 'URL');\n  var sanitized = sanitizeUrl(url);\n  var parsedUrl = uriJsParse(sanitized.url);\n  var scheme = sanitized.schemeMissing ? null : extractScheme(parsedUrl.scheme);\n  var host = extractHost(parsedUrl.host); // no square brackets for IPv6\n  var formattedHost = formatHost(host); // has square brackets for IPv6\n  var port = extractPort(parsedUrl.port, scheme);\n  var hostAndPort = formattedHost + \":\" + port;\n  var query = extractQuery(\n  // @ts-ignore\n  parsedUrl.query || extractResourceQueryString(parsedUrl.resourceName), url);\n  return new Url(scheme, host, port, hostAndPort, query);\n}\nexports.parseDatabaseUrl = parseDatabaseUrl;\nfunction extractResourceQueryString(resource) {\n  if (typeof resource !== 'string') {\n    return null;\n  }\n  var _a = __read(resource.split('?'), 2),\n    _ = _a[0],\n    query = _a[1];\n  return query;\n}\nfunction sanitizeUrl(url) {\n  url = url.trim();\n  if (url.indexOf('://') === -1) {\n    // url does not contain scheme, add dummy 'none://' to make parser work correctly\n    return {\n      schemeMissing: true,\n      url: \"none://\" + url\n    };\n  }\n  return {\n    schemeMissing: false,\n    url: url\n  };\n}\nfunction extractScheme(scheme) {\n  if (scheme) {\n    scheme = scheme.trim();\n    if (scheme.charAt(scheme.length - 1) === ':') {\n      scheme = scheme.substring(0, scheme.length - 1);\n    }\n    return scheme;\n  }\n  return null;\n}\nfunction extractHost(host, url) {\n  if (!host) {\n    throw new Error(\"Unable to extract host from \" + url);\n  }\n  return host.trim();\n}\nfunction extractPort(portString, scheme) {\n  var port = typeof portString === 'string' ? parseInt(portString, 10) : portString;\n  return port === 0 || port ? port : defaultPortForScheme(scheme);\n}\nfunction extractQuery(queryString, url) {\n  var query = queryString ? trimAndSanitizeQuery(queryString) : null;\n  var context = {};\n  if (query) {\n    query.split('&').forEach(function (pair) {\n      var keyValue = pair.split('=');\n      if (keyValue.length !== 2) {\n        throw new Error(\"Invalid parameters: '\" + keyValue + \"' in URL '\" + url + \"'.\");\n      }\n      var key = trimAndVerifyQueryElement(keyValue[0], 'key', url);\n      var value = trimAndVerifyQueryElement(keyValue[1], 'value', url);\n      if (context[key]) {\n        throw new Error(\"Duplicated query parameters with key '\" + key + \"' in URL '\" + url + \"'\");\n      }\n      context[key] = value;\n    });\n  }\n  return context;\n}\nfunction trimAndSanitizeQuery(query) {\n  query = (query || '').trim();\n  if (query && query.charAt(0) === '?') {\n    query = query.substring(1, query.length);\n  }\n  return query;\n}\nfunction trimAndVerifyQueryElement(element, name, url) {\n  element = (element || '').trim();\n  if (!element) {\n    throw new Error(\"Illegal empty \" + name + \" in URL query '\" + url + \"'\");\n  }\n  return element;\n}\nfunction escapeIPv6Address(address) {\n  var startsWithSquareBracket = address.charAt(0) === '[';\n  var endsWithSquareBracket = address.charAt(address.length - 1) === ']';\n  if (!startsWithSquareBracket && !endsWithSquareBracket) {\n    return \"[\" + address + \"]\";\n  } else if (startsWithSquareBracket && endsWithSquareBracket) {\n    return address;\n  } else {\n    throw new Error(\"Illegal IPv6 address \" + address);\n  }\n}\nfunction formatHost(host) {\n  if (!host) {\n    throw new Error(\"Illegal host \" + host);\n  }\n  var isIPv6Address = host.indexOf(':') >= 0;\n  return isIPv6Address ? escapeIPv6Address(host) : host;\n}\nfunction formatIPv4Address(address, port) {\n  return address + \":\" + port;\n}\nexports.formatIPv4Address = formatIPv4Address;\nfunction formatIPv6Address(address, port) {\n  var escapedAddress = escapeIPv6Address(address);\n  return escapedAddress + \":\" + port;\n}\nexports.formatIPv6Address = formatIPv6Address;\nfunction defaultPortForScheme(scheme) {\n  if (scheme === 'http') {\n    return DEFAULT_HTTP_PORT;\n  } else if (scheme === 'https') {\n    return DEFAULT_HTTPS_PORT;\n  } else {\n    return DEFAULT_BOLT_PORT;\n  }\n}\nexports.defaultPortForScheme = defaultPortForScheme;\nfunction uriJsParse(value) {\n  // JS version of Python partition function\n  function partition(s, delimiter) {\n    var i = s.indexOf(delimiter);\n    if (i >= 0) return [s.substring(0, i), s[i], s.substring(i + 1)];else return [s, '', ''];\n  }\n  // JS version of Python rpartition function\n  function rpartition(s, delimiter) {\n    var i = s.lastIndexOf(delimiter);\n    if (i >= 0) return [s.substring(0, i), s[i], s.substring(i + 1)];else return ['', '', s];\n  }\n  function between(s, ldelimiter, rdelimiter) {\n    var lpartition = partition(s, ldelimiter);\n    var rpartition = partition(lpartition[2], rdelimiter);\n    return [rpartition[0], rpartition[2]];\n  }\n  // Parse an authority string into an object\n  // with the following keys:\n  // - userInfo (optional, might contain both user name and password)\n  // - host\n  // - port (optional, included only as a string)\n  function parseAuthority(value) {\n    var parsed = {},\n      parts;\n    // Parse user info\n    parts = rpartition(value, '@');\n    if (parts[1] === '@') {\n      parsed.userInfo = decodeURIComponent(parts[0]);\n      value = parts[2];\n    }\n    // Parse host and port\n    var _a = __read(between(value, \"[\", \"]\"), 2),\n      ipv6Host = _a[0],\n      rest = _a[1];\n    if (ipv6Host !== '') {\n      parsed.host = ipv6Host;\n      parts = partition(rest, ':');\n    } else {\n      parts = partition(value, ':');\n      parsed.host = parts[0];\n    }\n    if (parts[1] === ':') {\n      parsed.port = parts[2];\n    }\n    return parsed;\n  }\n  var parsed = {},\n    parts;\n  // Parse scheme\n  parts = partition(value, ':');\n  if (parts[1] === ':') {\n    parsed.scheme = decodeURIComponent(parts[0]);\n    value = parts[2];\n  }\n  // Parse fragment\n  parts = partition(value, '#');\n  if (parts[1] === '#') {\n    parsed.fragment = decodeURIComponent(parts[2]);\n    value = parts[0];\n  }\n  // Parse query\n  parts = partition(value, '?');\n  if (parts[1] === '?') {\n    parsed.query = parts[2];\n    value = parts[0];\n  }\n  // Parse authority and path\n  if (value.startsWith('//')) {\n    parts = partition(value.substr(2), '/');\n    parsed = __assign(__assign({}, parsed), parseAuthority(parts[0]));\n    parsed.path = parts[1] + parts[2];\n  } else {\n    parsed.path = value;\n  }\n  return parsed;\n}","map":null,"metadata":{},"sourceType":"script"}