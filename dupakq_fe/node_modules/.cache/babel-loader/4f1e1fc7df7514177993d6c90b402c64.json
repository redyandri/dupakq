{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2]) _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createChannelConnection = void 0;\nvar channel_1 = require(\"../channel\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar connection_1 = __importDefault(require(\"./connection\"));\nvar bolt_1 = __importDefault(require(\"../bolt\"));\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar Logger = neo4j_driver_core_1.internal.logger.Logger;\nvar idGenerator = 0;\n/**\n * Crete new connection to the provided address. Returned connection is not connected.\n * @param {ServerAddress} address - the Bolt endpoint to connect to.\n * @param {Object} config - the driver configuration.\n * @param {ConnectionErrorHandler} errorHandler - the error handler for connection errors.\n * @param {Logger} log - configured logger.\n * @return {Connection} - new connection.\n */\nfunction createChannelConnection(address, config, errorHandler, log, serversideRouting, createChannel) {\n  if (serversideRouting === void 0) {\n    serversideRouting = null;\n  }\n  if (createChannel === void 0) {\n    createChannel = function createChannel(channelConfig) {\n      return new channel_1.Channel(channelConfig);\n    };\n  }\n  var channelConfig = new channel_1.ChannelConfig(address, config, errorHandler.errorCode());\n  var channel = createChannel(channelConfig);\n  return bolt_1.default.handshake(channel).then(function (_a) {\n    var version = _a.protocolVersion,\n      consumeRemainingBuffer = _a.consumeRemainingBuffer;\n    var chunker = new channel_1.Chunker(channel);\n    var dechunker = new channel_1.Dechunker();\n    var createProtocol = function createProtocol(conn) {\n      return bolt_1.default.create({\n        version: version,\n        channel: channel,\n        chunker: chunker,\n        dechunker: dechunker,\n        disableLosslessIntegers: config.disableLosslessIntegers,\n        useBigInt: config.useBigInt,\n        serversideRouting: serversideRouting,\n        server: conn.server,\n        log: conn.logger,\n        observer: {\n          onPendingObserversChange: conn._handleOngoingRequestsNumberChange.bind(conn),\n          onError: conn._handleFatalError.bind(conn),\n          onFailure: conn._resetOnFailure.bind(conn),\n          onProtocolError: conn._handleProtocolError.bind(conn),\n          onErrorApplyTransformation: function onErrorApplyTransformation(error) {\n            return conn.handleAndTransformError(error, conn._address);\n          }\n        }\n      });\n    };\n    var connection = new ChannelConnection(channel, errorHandler, address, log, config.disableLosslessIntegers, serversideRouting, chunker, createProtocol);\n    // forward all pending bytes to the dechunker\n    consumeRemainingBuffer(function (buffer) {\n      return dechunker.write(buffer);\n    });\n    return connection;\n  }).catch(function (reason) {\n    return channel.close().then(function () {\n      throw reason;\n    });\n  });\n}\nexports.createChannelConnection = createChannelConnection;\nvar ChannelConnection = /** @class */function (_super) {\n  __extends(ChannelConnection, _super);\n  /**\n   * @constructor\n   * @param {Channel} channel - channel with a 'write' function and a 'onmessage' callback property.\n   * @param {ConnectionErrorHandler} errorHandler the error handler.\n   * @param {ServerAddress} address - the server address to connect to.\n   * @param {Logger} log - the configured logger.\n   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.\n   * @param {Chunker} chunker the chunker\n   * @param protocolSupplier Bolt protocol supplier\n   */\n  function ChannelConnection(channel, errorHandler, address, log, disableLosslessIntegers, serversideRouting, chunker,\n  // to be removed,\n  protocolSupplier) {\n    if (disableLosslessIntegers === void 0) {\n      disableLosslessIntegers = false;\n    }\n    if (serversideRouting === void 0) {\n      serversideRouting = null;\n    }\n    var _this = _super.call(this, errorHandler) || this;\n    _this._id = idGenerator++;\n    _this._address = address;\n    _this._server = {\n      address: address.asHostPort()\n    };\n    _this.creationTimestamp = Date.now();\n    _this._disableLosslessIntegers = disableLosslessIntegers;\n    _this._ch = channel;\n    _this._chunker = chunker;\n    _this._log = createConnectionLogger(_this, log);\n    _this._serversideRouting = serversideRouting;\n    // connection from the database, returned in response for HELLO message and might not be available\n    _this._dbConnectionId = null;\n    // bolt protocol is initially not initialized\n    /**\n     * @private\n     * @type {BoltProtocol}\n     */\n    _this._protocol = protocolSupplier(_this);\n    // Set to true on fatal errors, to get this out of connection pool.\n    _this._isBroken = false;\n    if (_this._log.isDebugEnabled()) {\n      _this._log.debug(\"created towards \" + address);\n    }\n    return _this;\n  }\n  Object.defineProperty(ChannelConnection.prototype, \"id\", {\n    get: function get() {\n      return this._id;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ChannelConnection.prototype, \"databaseId\", {\n    get: function get() {\n      return this._dbConnectionId;\n    },\n    set: function set(value) {\n      this._dbConnectionId = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Send initialization message.\n   * @param {string} userAgent the user agent for this driver.\n   * @param {Object} authToken the object containing auth information.\n   * @return {Promise<Connection>} promise resolved with the current connection if connection is successful. Rejected promise otherwise.\n   */\n  ChannelConnection.prototype.connect = function (userAgent, authToken) {\n    return this._initialize(userAgent, authToken);\n  };\n  /**\n   * Perform protocol-specific initialization which includes authentication.\n   * @param {string} userAgent the user agent for this driver.\n   * @param {Object} authToken the object containing auth information.\n   * @return {Promise<Connection>} promise resolved with the current connection if initialization is successful. Rejected promise otherwise.\n   */\n  ChannelConnection.prototype._initialize = function (userAgent, authToken) {\n    var _this = this;\n    var self = this;\n    return new Promise(function (resolve, reject) {\n      _this._protocol.initialize({\n        userAgent: userAgent,\n        authToken: authToken,\n        onError: function onError(err) {\n          return reject(err);\n        },\n        onComplete: function onComplete(metadata) {\n          if (metadata) {\n            // read server version from the response metadata, if it is available\n            var serverVersion = metadata.server;\n            if (!_this.version || serverVersion) {\n              _this.version = serverVersion;\n            }\n            // read database connection id from the response metadata, if it is available\n            var dbConnectionId = metadata.connection_id;\n            if (!_this.databaseId) {\n              _this.databaseId = dbConnectionId;\n            }\n            if (metadata.hints) {\n              var receiveTimeoutRaw = metadata.hints['connection.recv_timeout_seconds'];\n              if (receiveTimeoutRaw !== null && receiveTimeoutRaw !== undefined) {\n                var receiveTimeoutInSeconds = (0, neo4j_driver_core_1.toNumber)(receiveTimeoutRaw);\n                if (Number.isInteger(receiveTimeoutInSeconds) && receiveTimeoutInSeconds > 0) {\n                  _this._ch.setupReceiveTimeout(receiveTimeoutInSeconds * 1000);\n                } else {\n                  _this._log.info(\"Server located at \" + _this._address + \" supplied an invalid connection receive timeout value (\" + receiveTimeoutInSeconds + \"). \" + 'Please, verify the server configuration and status because this can be the symptom of a bigger issue.');\n                }\n              }\n            }\n          }\n          resolve(self);\n        }\n      });\n    });\n  };\n  /**\n   * Get the Bolt protocol for the connection.\n   * @return {BoltProtocol} the protocol.\n   */\n  ChannelConnection.prototype.protocol = function () {\n    return this._protocol;\n  };\n  Object.defineProperty(ChannelConnection.prototype, \"address\", {\n    get: function get() {\n      return this._address;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ChannelConnection.prototype, \"version\", {\n    /**\n     * Get the version of the connected server.\n     * Available only after initialization\n     *\n     * @returns {ServerVersion} version\n     */\n    get: function get() {\n      return this._server.version;\n    },\n    set: function set(value) {\n      this._server.version = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ChannelConnection.prototype, \"server\", {\n    get: function get() {\n      return this._server;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ChannelConnection.prototype, \"logger\", {\n    get: function get() {\n      return this._log;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * \"Fatal\" means the connection is dead. Only call this if something\n   * happens that cannot be recovered from. This will lead to all subscribers\n   * failing, and the connection getting ejected from the session pool.\n   *\n   * @param error an error object, forwarded to all current and future subscribers\n   */\n  ChannelConnection.prototype._handleFatalError = function (error) {\n    this._isBroken = true;\n    this._error = this.handleAndTransformError(this._protocol.currentFailure || error, this._address);\n    if (this._log.isErrorEnabled()) {\n      this._log.error(\"experienced a fatal error caused by \" + this._error + \" (\" + neo4j_driver_core_1.json.stringify(this._error) + \")\");\n    }\n    this._protocol.notifyFatalError(this._error);\n  };\n  /**\n   * This method still here because it's used by the {@link PooledConnectionProvider}\n   *\n   * @param {any} observer\n   */\n  ChannelConnection.prototype._queueObserver = function (observer) {\n    return this._protocol.queueObserverIfProtocolIsNotBroken(observer);\n  };\n  ChannelConnection.prototype.hasOngoingObservableRequests = function () {\n    return this._protocol.hasOngoingObservableRequests();\n  };\n  /**\n   * Send a RESET-message to the database. Message is immediately flushed to the network.\n   * @return {Promise<void>} promise resolved when SUCCESS-message response arrives, or failed when other response messages arrives.\n   */\n  ChannelConnection.prototype.resetAndFlush = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this._protocol.reset({\n        onError: function onError(error) {\n          if (_this._isBroken) {\n            // handling a fatal error, no need to raise a protocol violation\n            reject(error);\n          } else {\n            var neo4jError = _this._handleProtocolError('Received FAILURE as a response for RESET: ' + error);\n            reject(neo4jError);\n          }\n        },\n        onComplete: function onComplete() {\n          resolve();\n        }\n      });\n    });\n  };\n  ChannelConnection.prototype._resetOnFailure = function () {\n    var _this = this;\n    if (!this.isOpen()) {\n      return;\n    }\n    this._protocol.reset({\n      onError: function onError() {\n        _this._protocol.resetFailure();\n      },\n      onComplete: function onComplete() {\n        _this._protocol.resetFailure();\n      }\n    });\n  };\n  /*\n   * Pop next pending observer form the list of observers and make it current observer.\n   * @protected\n   */\n  ChannelConnection.prototype._updateCurrentObserver = function () {\n    this._protocol.updateCurrentObserver();\n  };\n  /** Check if this connection is in working condition */\n  ChannelConnection.prototype.isOpen = function () {\n    return !this._isBroken && this._ch._open;\n  };\n  /**\n   * Starts and stops the receive timeout timer.\n   * @param {number} requestsNumber Ongoing requests number\n   */\n  ChannelConnection.prototype._handleOngoingRequestsNumberChange = function (requestsNumber) {\n    if (requestsNumber === 0) {\n      this._ch.stopReceiveTimeout();\n    } else {\n      this._ch.startReceiveTimeout();\n    }\n  };\n  /**\n   * Call close on the channel.\n   * @returns {Promise<void>} - A promise that will be resolved when the underlying channel is closed.\n   */\n  ChannelConnection.prototype.close = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this._log.isDebugEnabled()) {\n              this._log.debug('closing');\n            }\n            if (this._protocol && this.isOpen()) {\n              // protocol has been initialized and this connection is healthy\n              // notify the database about the upcoming close of the connection\n              this._protocol.prepareToClose();\n            }\n            return [4 /*yield*/, this._ch.close()];\n          case 1:\n            _a.sent();\n            if (this._log.isDebugEnabled()) {\n              this._log.debug('closed');\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  ChannelConnection.prototype.toString = function () {\n    return \"Connection [\" + this.id + \"][\" + (this.databaseId || '') + \"]\";\n  };\n  ChannelConnection.prototype._handleProtocolError = function (message) {\n    this._protocol.resetFailure();\n    this._updateCurrentObserver();\n    var error = (0, neo4j_driver_core_1.newError)(message, PROTOCOL_ERROR);\n    this._handleFatalError(error);\n    return error;\n  };\n  return ChannelConnection;\n}(connection_1.default);\nexports.default = ChannelConnection;\n/**\n * Creates a log with the connection info as prefix\n * @param {Connection} connection The connection\n * @param {Logger} logger The logger\n * @returns {Logger} The new logger with enriched messages\n */\nfunction createConnectionLogger(connection, logger) {\n  return new Logger(logger._level, function (level, message) {\n    return logger._loggerFunction(level, connection + \" \" + message);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}