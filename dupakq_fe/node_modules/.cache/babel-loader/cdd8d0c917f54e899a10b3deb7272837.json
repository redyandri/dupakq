{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createValidRoutingTable = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar _a = neo4j_driver_core_1.internal.constants,\n  WRITE = _a.ACCESS_MODE_WRITE,\n  READ = _a.ACCESS_MODE_READ,\n  ServerAddress = neo4j_driver_core_1.internal.serverAddress.ServerAddress;\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar MIN_ROUTERS = 1;\n/**\n * The routing table object used to determine the role of the servers in the driver.\n */\nvar RoutingTable = /** @class */function () {\n  function RoutingTable(_a) {\n    var _b = _a === void 0 ? {} : _a,\n      database = _b.database,\n      routers = _b.routers,\n      readers = _b.readers,\n      writers = _b.writers,\n      expirationTime = _b.expirationTime,\n      ttl = _b.ttl;\n    this.database = database || null;\n    this.databaseName = database || 'default database';\n    this.routers = routers || [];\n    this.readers = readers || [];\n    this.writers = writers || [];\n    this.expirationTime = expirationTime || (0, neo4j_driver_core_1.int)(0);\n    this.ttl = ttl;\n  }\n  /**\n   * Create a valid routing table from a raw object\n   *\n   * @param {string} database the database name. It is used for logging purposes\n   * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\n   * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\n   * @param {RoutingTable} The valid Routing Table\n   */\n  RoutingTable.fromRawRoutingTable = function (database, routerAddress, rawRoutingTable) {\n    return createValidRoutingTable(database, routerAddress, rawRoutingTable);\n  };\n  RoutingTable.prototype.forget = function (address) {\n    // Don't remove it from the set of routers, since that might mean we lose our ability to re-discover,\n    // just remove it from the set of readers and writers, so that we don't use it for actual work without\n    // performing discovery first.\n    this.readers = removeFromArray(this.readers, address);\n    this.writers = removeFromArray(this.writers, address);\n  };\n  RoutingTable.prototype.forgetRouter = function (address) {\n    this.routers = removeFromArray(this.routers, address);\n  };\n  RoutingTable.prototype.forgetWriter = function (address) {\n    this.writers = removeFromArray(this.writers, address);\n  };\n  /**\n   * Check if this routing table is fresh to perform the required operation.\n   * @param {string} accessMode the type of operation. Allowed values are {@link READ} and {@link WRITE}.\n   * @return {boolean} `true` when this table contains servers to serve the required operation, `false` otherwise.\n   */\n  RoutingTable.prototype.isStaleFor = function (accessMode) {\n    return this.expirationTime.lessThan(Date.now()) || this.routers.length < MIN_ROUTERS || accessMode === READ && this.readers.length === 0 || accessMode === WRITE && this.writers.length === 0;\n  };\n  /**\n   * Check if this routing table is expired for specified amount of duration\n   *\n   * @param {Integer} duration amount of duration in milliseconds to check for expiration\n   * @returns {boolean}\n   */\n  RoutingTable.prototype.isExpiredFor = function (duration) {\n    return this.expirationTime.add(duration).lessThan(Date.now());\n  };\n  RoutingTable.prototype.allServers = function () {\n    return __spreadArray(__spreadArray(__spreadArray([], __read(this.routers), false), __read(this.readers), false), __read(this.writers), false);\n  };\n  RoutingTable.prototype.toString = function () {\n    return 'RoutingTable[' + (\"database=\" + this.databaseName + \", \") + (\"expirationTime=\" + this.expirationTime + \", \") + (\"currentTime=\" + Date.now() + \", \") + (\"routers=[\" + this.routers + \"], \") + (\"readers=[\" + this.readers + \"], \") + (\"writers=[\" + this.writers + \"]]\");\n  };\n  return RoutingTable;\n}();\nexports.default = RoutingTable;\n/**\n * Remove all occurrences of the element in the array.\n * @param {Array} array the array to filter.\n * @param {Object} element the element to remove.\n * @return {Array} new filtered array.\n */\nfunction removeFromArray(array, element) {\n  return array.filter(function (item) {\n    return item.asKey() !== element.asKey();\n  });\n}\n/**\n * Create a valid routing table from a raw object\n *\n * @param {string} db the database name. It is used for logging purposes\n * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\n * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\n * @param {RoutingTable} The valid Routing Table\n */\nfunction createValidRoutingTable(database, routerAddress, rawRoutingTable) {\n  var ttl = rawRoutingTable.ttl;\n  var expirationTime = calculateExpirationTime(rawRoutingTable, routerAddress);\n  var _a = parseServers(rawRoutingTable, routerAddress),\n    routers = _a.routers,\n    readers = _a.readers,\n    writers = _a.writers;\n  assertNonEmpty(routers, 'routers', routerAddress);\n  assertNonEmpty(readers, 'readers', routerAddress);\n  return new RoutingTable({\n    database: database || rawRoutingTable.db,\n    routers: routers,\n    readers: readers,\n    writers: writers,\n    expirationTime: expirationTime,\n    ttl: ttl\n  });\n}\nexports.createValidRoutingTable = createValidRoutingTable;\n/**\n * Parse server from the RawRoutingTable.\n *\n * @param {RawRoutingTable} rawRoutingTable the raw routing table\n * @param {string} routerAddress the router address\n * @returns {Object} The object with the list of routers, readers and writers\n */\nfunction parseServers(rawRoutingTable, routerAddress) {\n  try {\n    var routers_1 = [];\n    var readers_1 = [];\n    var writers_1 = [];\n    rawRoutingTable.servers.forEach(function (server) {\n      var role = server.role;\n      var addresses = server.addresses;\n      if (role === 'ROUTE') {\n        routers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      } else if (role === 'WRITE') {\n        writers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      } else if (role === 'READ') {\n        readers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      }\n    });\n    return {\n      routers: routers_1,\n      readers: readers_1,\n      writers: writers_1\n    };\n  } catch (error) {\n    throw (0, neo4j_driver_core_1.newError)(\"Unable to parse servers entry from router \" + routerAddress + \" from addresses:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable.servers) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n  }\n}\n/**\n * Call the expiration time using the ttls from the raw routing table and return it\n *\n * @param {RawRoutingTable} rawRoutingTable the routing table\n * @param {string} routerAddress the router address\n * @returns {number} the ttl\n */\nfunction calculateExpirationTime(rawRoutingTable, routerAddress) {\n  try {\n    var now = (0, neo4j_driver_core_1.int)(Date.now());\n    var expires = (0, neo4j_driver_core_1.int)(rawRoutingTable.ttl).multiply(1000).add(now);\n    // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed\n    if (expires.lessThan(now)) {\n      return neo4j_driver_core_1.Integer.MAX_VALUE;\n    }\n    return expires;\n  } catch (error) {\n    throw (0, neo4j_driver_core_1.newError)(\"Unable to parse TTL entry from router \" + routerAddress + \" from raw routing table:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n  }\n}\n/**\n * Assert if serverAddressesArray is not empty, throws and PROTOCOL_ERROR otherwise\n *\n * @param {string[]} serverAddressesArray array of addresses\n * @param {string} serversName the server name\n * @param {string} routerAddress the router address\n */\nfunction assertNonEmpty(serverAddressesArray, serversName, routerAddress) {\n  if (serverAddressesArray.length === 0) {\n    throw (0, neo4j_driver_core_1.newError)('Received no ' + serversName + ' from router ' + routerAddress, PROTOCOL_ERROR);\n  }\n}\nfunction parseArray(addresses) {\n  if (!Array.isArray(addresses)) {\n    throw new TypeError('Array expected but got: ' + addresses);\n  }\n  return Array.from(addresses);\n}","map":null,"metadata":{},"sourceType":"script"}