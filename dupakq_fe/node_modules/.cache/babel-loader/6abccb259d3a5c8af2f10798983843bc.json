{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.packDateTime = exports.unpackDateTimeWithZoneId = exports.unpackDateTimeWithZoneOffset = exports.DATE_TIME_WITH_ZONE_ID = exports.DATE_TIME_WITH_ZONE_OFFSET = void 0;\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar temporal_factory_1 = require(\"./temporal-factory\");\nvar localDateTimeToEpochSecond = neo4j_driver_core_1.internal.temporalUtil.localDateTimeToEpochSecond;\nexports.DATE_TIME_WITH_ZONE_OFFSET = 0x49;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nexports.DATE_TIME_WITH_ZONE_ID = 0x69;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\n/**\n* Unpack date time with zone offset value using the given unpacker.\n* @param {Unpacker} unpacker the unpacker to use.\n* @param {number} structSize the retrieved struct size.\n* @param {BaseBuffer} buffer the buffer to unpack from.\n* @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n* @return {DateTime} the unpacked date time with zone offset value.\n*/\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\n  var utcSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\n  var epochSecond = (0, neo4j_driver_core_1.int)(utcSecond).add(timeZoneOffsetSeconds);\n  var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\nexports.unpackDateTimeWithZoneOffset = unpackDateTimeWithZoneOffset;\n/**\n * Unpack date time with zone id value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone id value.\n */\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneId = unpacker.unpack(buffer);\n  var localDateTime = getTimeInZoneId(timeZoneId, epochSecond, nano);\n  var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, (0, neo4j_driver_core_1.int)(nano), localDateTime.timeZoneOffsetSeconds, timeZoneId);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\nexports.unpackDateTimeWithZoneId = unpackDateTimeWithZoneId;\n/*\n* Pack given date time.\n* @param {DateTime} value the date time value to pack.\n* @param {Packer} packer the packer to use.\n*/\nfunction packDateTime(value, packer) {\n  if (value.timeZoneId) {\n    packDateTimeWithZoneId(value, packer);\n  } else {\n    packDateTimeWithZoneOffset(value, packer);\n  }\n}\nexports.packDateTime = packDateTime;\n/**\n * Pack given date time with zone id.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTimeWithZoneId(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var offset = value.timeZoneOffsetSeconds != null ? value.timeZoneOffsetSeconds : getOffsetFromZoneId(value.timeZoneId, epochSecond, value.nanosecond);\n  var utc = epochSecond.subtract(offset);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var timeZoneId = value.timeZoneId;\n  var packableStructFields = [packer.packable(utc), packer.packable(nano), packer.packable(timeZoneId)];\n  packer.packStruct(exports.DATE_TIME_WITH_ZONE_ID, packableStructFields);\n}\n/**\n * Pack given date time with zone offset.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTimeWithZoneOffset(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n  var utcSecond = epochSecond.subtract(timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(utcSecond), packer.packable(nano), packer.packable(timeZoneOffsetSeconds)];\n  packer.packStruct(exports.DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);\n}\n/**\n * Returns the offset for a given timezone id\n *\n * Javascript doesn't have support for direct getting the timezone offset from a given\n * TimeZoneId and DateTime in the given TimeZoneId. For solving this issue,\n *\n * 1. The ZoneId is applied to the timestamp, so we could make the difference between the\n * given timestamp and the new calculated one. This is the offset for the timezone\n * in the utc is equal to epoch (some time in the future or past)\n * 2. The offset is subtracted from the timestamp, so we have an estimated utc timestamp.\n * 3. The ZoneId is applied to the new timestamp, se we could could make the difference\n * between the new timestamp and the calculated one. This is the offset for the given timezone.\n *\n * Example:\n *    Input: 2022-3-27 1:59:59 'Europe/Berlin'\n *    Apply 1, 2022-3-27 1:59:59 => 2022-3-27 3:59:59 'Europe/Berlin' +2:00\n *    Apply 2, 2022-3-27 1:59:59 - 2:00 => 2022-3-26 23:59:59\n *    Apply 3, 2022-3-26 23:59:59 => 2022-3-27 00:59:59 'Europe/Berlin' +1:00\n *  The offset is +1 hour.\n *\n * @param {string} timeZoneId The timezone id\n * @param {Integer} epochSecond The epoch second in the timezone id\n * @param {Integerable} nanosecond The nanoseconds in the timezone id\n * @returns The timezone offset\n */\nfunction getOffsetFromZoneId(timeZoneId, epochSecond, nanosecond) {\n  var dateTimeWithZoneAppliedTwice = getTimeInZoneId(timeZoneId, epochSecond, nanosecond);\n  // The wallclock form the current date time\n  var epochWithZoneAppliedTwice = localDateTimeToEpochSecond(dateTimeWithZoneAppliedTwice.year, dateTimeWithZoneAppliedTwice.month, dateTimeWithZoneAppliedTwice.day, dateTimeWithZoneAppliedTwice.hour, dateTimeWithZoneAppliedTwice.minute, dateTimeWithZoneAppliedTwice.second, nanosecond);\n  var offsetOfZoneInTheFutureUtc = epochWithZoneAppliedTwice.subtract(epochSecond);\n  var guessedUtc = epochSecond.subtract(offsetOfZoneInTheFutureUtc);\n  var zonedDateTimeFromGuessedUtc = getTimeInZoneId(timeZoneId, guessedUtc, nanosecond);\n  var zonedEpochFromGuessedUtc = localDateTimeToEpochSecond(zonedDateTimeFromGuessedUtc.year, zonedDateTimeFromGuessedUtc.month, zonedDateTimeFromGuessedUtc.day, zonedDateTimeFromGuessedUtc.hour, zonedDateTimeFromGuessedUtc.minute, zonedDateTimeFromGuessedUtc.second, nanosecond);\n  var offset = zonedEpochFromGuessedUtc.subtract(guessedUtc);\n  return offset;\n}\nfunction getTimeInZoneId(timeZoneId, epochSecond, nano) {\n  var formatter = new Intl.DateTimeFormat('en-US', {\n    timeZone: timeZoneId,\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric',\n    second: 'numeric',\n    hour12: false,\n    era: 'narrow'\n  });\n  var utc = (0, neo4j_driver_core_1.int)(epochSecond).multiply(1000).add((0, neo4j_driver_core_1.int)(nano).div(1000000)).toNumber();\n  var formattedUtcParts = formatter.formatToParts(utc);\n  var localDateTime = formattedUtcParts.reduce(function (obj, currentValue) {\n    if (currentValue.type === 'era') {\n      obj.adjustEra = currentValue.value.toUpperCase() === 'B' ? function (year) {\n        return year.subtract(1).negate();\n      } // 1BC equals to year 0 in astronomical year numbering\n      : function (year) {\n        return year;\n      };\n    } else if (currentValue.type !== 'literal') {\n      obj[currentValue.type] = (0, neo4j_driver_core_1.int)(currentValue.value);\n    }\n    return obj;\n  }, {});\n  localDateTime.year = localDateTime.adjustEra(localDateTime.year);\n  var epochInTimeZone = localDateTimeToEpochSecond(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond);\n  localDateTime.timeZoneOffsetSeconds = epochInTimeZone.subtract(epochSecond);\n  localDateTime.hour = localDateTime.hour.modulo(24);\n  return localDateTime;\n}\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n  if (!disableLosslessIntegers && !useBigInt) {\n    return obj;\n  }\n  var convert = function convert(value) {\n    return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n  };\n  var clone = Object.create(Object.getPrototypeOf(obj));\n  for (var prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop) === true) {\n      var value = obj[prop];\n      clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n    }\n  }\n  Object.freeze(clone);\n  return clone;\n}","map":null,"metadata":{},"sourceType":"script"}