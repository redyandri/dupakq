{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _neo4jDriverCore = require(\"neo4j-driver-core\");\nvar _rxjs = require(\"rxjs\");\nvar _operators = require(\"rxjs/operators\");\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Logger = _neo4jDriverCore.internal.logger.Logger,\n  canRetryOn = _neo4jDriverCore.internal.retryStrategy.canRetryOn;\nvar SERVICE_UNAVAILABLE = _neo4jDriverCore.error.SERVICE_UNAVAILABLE,\n  SESSION_EXPIRED = _neo4jDriverCore.error.SESSION_EXPIRED;\nvar DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds\n\nvar DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds\n\nvar DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;\nvar DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;\nvar RxRetryLogic = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {Object} args\n   * @param {Logger} args.logger\n   */\n  function RxRetryLogic() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$maxRetryTimeout = _ref.maxRetryTimeout,\n      maxRetryTimeout = _ref$maxRetryTimeout === void 0 ? DEFAULT_MAX_RETRY_TIME_MS : _ref$maxRetryTimeout,\n      _ref$initialDelay = _ref.initialDelay,\n      initialDelay = _ref$initialDelay === void 0 ? DEFAULT_INITIAL_RETRY_DELAY_MS : _ref$initialDelay,\n      _ref$delayMultiplier = _ref.delayMultiplier,\n      delayMultiplier = _ref$delayMultiplier === void 0 ? DEFAULT_RETRY_DELAY_MULTIPLIER : _ref$delayMultiplier,\n      _ref$delayJitter = _ref.delayJitter,\n      delayJitter = _ref$delayJitter === void 0 ? DEFAULT_RETRY_DELAY_JITTER_FACTOR : _ref$delayJitter,\n      _ref$logger = _ref.logger,\n      logger = _ref$logger === void 0 ? null : _ref$logger;\n    (0, _classCallCheck2[\"default\"])(this, RxRetryLogic);\n    this._maxRetryTimeout = valueOrDefault(maxRetryTimeout, DEFAULT_MAX_RETRY_TIME_MS);\n    this._initialDelay = valueOrDefault(initialDelay, DEFAULT_INITIAL_RETRY_DELAY_MS);\n    this._delayMultiplier = valueOrDefault(delayMultiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);\n    this._delayJitter = valueOrDefault(delayJitter, DEFAULT_RETRY_DELAY_JITTER_FACTOR);\n    this._logger = logger;\n  }\n  /**\n   *\n   * @param {Observable<Any>} work\n   */\n\n  (0, _createClass2[\"default\"])(RxRetryLogic, [{\n    key: \"retry\",\n    value: function retry(work) {\n      var _this = this;\n      return work.pipe((0, _operators.retryWhen)(function (failedWork) {\n        var handledExceptions = [];\n        var startTime = Date.now();\n        var retryCount = 1;\n        var delayDuration = _this._initialDelay;\n        return failedWork.pipe((0, _operators.flatMap)(function (err) {\n          if (!canRetryOn(err)) {\n            return (0, _rxjs.throwError)(err);\n          }\n          handledExceptions.push(err);\n          if (retryCount >= 2 && Date.now() - startTime >= _this._maxRetryTimeout) {\n            var _error = (0, _neo4jDriverCore.newError)(\"Failed after retried for \".concat(retryCount, \" times in \").concat(_this._maxRetryTimeout, \" ms. Make sure that your database is online and retry again.\"), SERVICE_UNAVAILABLE);\n            _error.seenErrors = handledExceptions;\n            return (0, _rxjs.throwError)(_error);\n          }\n          var nextDelayDuration = _this._computeNextDelay(delayDuration);\n          delayDuration = delayDuration * _this._delayMultiplier;\n          retryCount++;\n          if (_this._logger) {\n            _this._logger.warn(\"Transaction failed and will be retried in \".concat(nextDelayDuration));\n          }\n          return (0, _rxjs.of)(1).pipe((0, _operators.delay)(nextDelayDuration));\n        }));\n      }));\n    }\n  }, {\n    key: \"_computeNextDelay\",\n    value: function _computeNextDelay(delay) {\n      var jitter = delay * this._delayJitter;\n      return delay - jitter + 2 * jitter * Math.random();\n    }\n  }]);\n  return RxRetryLogic;\n}();\nexports[\"default\"] = RxRetryLogic;\nfunction valueOrDefault(value, defaultValue) {\n  if (value || value === 0) {\n    return value;\n  }\n  return defaultValue;\n}","map":null,"metadata":{},"sourceType":"script"}