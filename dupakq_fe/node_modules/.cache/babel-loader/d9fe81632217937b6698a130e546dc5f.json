{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Common base with default implementation for most buffer methods.\n * Buffers are stateful - they track a current \"position\", this helps greatly\n * when reading and writing from them incrementally. You can also ignore the\n * stateful read/write methods.\n * readXXX and writeXXX-methods move the inner position of the buffer.\n * putXXX and getXXX-methods do not.\n * @access private\n */\nvar BaseBuffer = /** @class */function () {\n  /**\n   * Create a instance with the injected size.\n   * @constructor\n   * @param {Integer} size\n   */\n  function BaseBuffer(size) {\n    this.position = 0;\n    this.length = size;\n  }\n  BaseBuffer.prototype.getUInt8 = function (position) {\n    throw new Error('Not implemented');\n  };\n  BaseBuffer.prototype.getInt8 = function (position) {\n    throw new Error('Not implemented');\n  };\n  BaseBuffer.prototype.getFloat64 = function (position) {\n    throw new Error('Not implemented');\n  };\n  BaseBuffer.prototype.putUInt8 = function (position, val) {\n    throw new Error('Not implemented');\n  };\n  BaseBuffer.prototype.putInt8 = function (position, val) {\n    throw new Error('Not implemented');\n  };\n  BaseBuffer.prototype.putFloat64 = function (position, val) {\n    throw new Error('Not implemented');\n  };\n  /**\n   * @param p\n   */\n  BaseBuffer.prototype.getInt16 = function (p) {\n    return this.getInt8(p) << 8 | this.getUInt8(p + 1);\n  };\n  /**\n   * @param p\n   */\n  BaseBuffer.prototype.getUInt16 = function (p) {\n    return this.getUInt8(p) << 8 | this.getUInt8(p + 1);\n  };\n  /**\n   * @param p\n   */\n  BaseBuffer.prototype.getInt32 = function (p) {\n    return this.getInt8(p) << 24 | this.getUInt8(p + 1) << 16 | this.getUInt8(p + 2) << 8 | this.getUInt8(p + 3);\n  };\n  /**\n   * @param p\n   */\n  BaseBuffer.prototype.getUInt32 = function (p) {\n    return this.getUInt8(p) << 24 | this.getUInt8(p + 1) << 16 | this.getUInt8(p + 2) << 8 | this.getUInt8(p + 3);\n  };\n  /**\n   * @param p\n   */\n  BaseBuffer.prototype.getInt64 = function (p) {\n    return this.getInt8(p) << 56 | this.getUInt8(p + 1) << 48 | this.getUInt8(p + 2) << 40 | this.getUInt8(p + 3) << 32 | this.getUInt8(p + 4) << 24 | this.getUInt8(p + 5) << 16 | this.getUInt8(p + 6) << 8 | this.getUInt8(p + 7);\n  };\n  /**\n   * Get a slice of this buffer. This method does not copy any data,\n   * but simply provides a slice view of this buffer\n   * @param start\n   * @param length\n   */\n  BaseBuffer.prototype.getSlice = function (start, length) {\n    return new SliceBuffer(start, length, this);\n  };\n  /**\n   * @param p\n   * @param val\n   */\n  BaseBuffer.prototype.putInt16 = function (p, val) {\n    this.putInt8(p, val >> 8);\n    this.putUInt8(p + 1, val & 0xff);\n  };\n  /**\n   * @param p\n   * @param val\n   */\n  BaseBuffer.prototype.putUInt16 = function (p, val) {\n    this.putUInt8(p, val >> 8 & 0xff);\n    this.putUInt8(p + 1, val & 0xff);\n  };\n  /**\n   * @param p\n   * @param val\n   */\n  BaseBuffer.prototype.putInt32 = function (p, val) {\n    this.putInt8(p, val >> 24);\n    this.putUInt8(p + 1, val >> 16 & 0xff);\n    this.putUInt8(p + 2, val >> 8 & 0xff);\n    this.putUInt8(p + 3, val & 0xff);\n  };\n  /**\n   * @param p\n   * @param val\n   */\n  BaseBuffer.prototype.putUInt32 = function (p, val) {\n    this.putUInt8(p, val >> 24 & 0xff);\n    this.putUInt8(p + 1, val >> 16 & 0xff);\n    this.putUInt8(p + 2, val >> 8 & 0xff);\n    this.putUInt8(p + 3, val & 0xff);\n  };\n  /**\n   * @param p\n   * @param val\n   */\n  BaseBuffer.prototype.putInt64 = function (p, val) {\n    this.putInt8(p, val >> 48);\n    this.putUInt8(p + 1, val >> 42 & 0xff);\n    this.putUInt8(p + 2, val >> 36 & 0xff);\n    this.putUInt8(p + 3, val >> 30 & 0xff);\n    this.putUInt8(p + 4, val >> 24 & 0xff);\n    this.putUInt8(p + 5, val >> 16 & 0xff);\n    this.putUInt8(p + 6, val >> 8 & 0xff);\n    this.putUInt8(p + 7, val & 0xff);\n  };\n  /**\n   * @param position\n   * @param other\n   */\n  BaseBuffer.prototype.putBytes = function (position, other) {\n    for (var i = 0, end = other.remaining(); i < end; i++) {\n      this.putUInt8(position + i, other.readUInt8());\n    }\n  };\n  /**\n   * Read from state position.\n   */\n  BaseBuffer.prototype.readUInt8 = function () {\n    return this.getUInt8(this._updatePos(1));\n  };\n  /**\n   * Read from state position.\n   */\n  BaseBuffer.prototype.readInt8 = function () {\n    return this.getInt8(this._updatePos(1));\n  };\n  /**\n   * Read from state position.\n   */\n  BaseBuffer.prototype.readUInt16 = function () {\n    return this.getUInt16(this._updatePos(2));\n  };\n  /**\n   * Read from state position.\n   */\n  BaseBuffer.prototype.readUInt32 = function () {\n    return this.getUInt32(this._updatePos(4));\n  };\n  /**\n   * Read from state position.\n   */\n  BaseBuffer.prototype.readInt16 = function () {\n    return this.getInt16(this._updatePos(2));\n  };\n  /**\n   * Read from state position.\n   */\n  BaseBuffer.prototype.readInt32 = function () {\n    return this.getInt32(this._updatePos(4));\n  };\n  /**\n   * Read from state position.\n   */\n  BaseBuffer.prototype.readInt64 = function () {\n    return this.getInt32(this._updatePos(8));\n  };\n  /**\n   * Read from state position.\n   */\n  BaseBuffer.prototype.readFloat64 = function () {\n    return this.getFloat64(this._updatePos(8));\n  };\n  /**\n   * Write to state position.\n   * @param val\n   */\n  BaseBuffer.prototype.writeUInt8 = function (val) {\n    this.putUInt8(this._updatePos(1), val);\n  };\n  /**\n   * Write to state position.\n   * @param val\n   */\n  BaseBuffer.prototype.writeInt8 = function (val) {\n    this.putInt8(this._updatePos(1), val);\n  };\n  /**\n   * Write to state position.\n   * @param val\n   */\n  BaseBuffer.prototype.writeInt16 = function (val) {\n    this.putInt16(this._updatePos(2), val);\n  };\n  /**\n   * Write to state position.\n   * @param val\n   */\n  BaseBuffer.prototype.writeInt32 = function (val) {\n    this.putInt32(this._updatePos(4), val);\n  };\n  /**\n   * Write to state position.\n   * @param val\n   */\n  BaseBuffer.prototype.writeUInt32 = function (val) {\n    this.putUInt32(this._updatePos(4), val);\n  };\n  /**\n   * Write to state position.\n   * @param val\n   */\n  BaseBuffer.prototype.writeInt64 = function (val) {\n    this.putInt64(this._updatePos(8), val);\n  };\n  /**\n   * Write to state position.\n   * @param val\n   */\n  BaseBuffer.prototype.writeFloat64 = function (val) {\n    this.putFloat64(this._updatePos(8), val);\n  };\n  /**\n   * Write to state position.\n   * @param val\n   */\n  BaseBuffer.prototype.writeBytes = function (val) {\n    this.putBytes(this._updatePos(val.remaining()), val);\n  };\n  /**\n   * Get a slice of this buffer. This method does not copy any data,\n   * but simply provides a slice view of this buffer\n   * @param length\n   */\n  BaseBuffer.prototype.readSlice = function (length) {\n    return this.getSlice(this._updatePos(length), length);\n  };\n  BaseBuffer.prototype._updatePos = function (length) {\n    var p = this.position;\n    this.position += length;\n    return p;\n  };\n  /**\n   * Get remaining\n   */\n  BaseBuffer.prototype.remaining = function () {\n    return this.length - this.position;\n  };\n  /**\n   * Has remaining\n   */\n  BaseBuffer.prototype.hasRemaining = function () {\n    return this.remaining() > 0;\n  };\n  /**\n   * Reset position state\n   */\n  BaseBuffer.prototype.reset = function () {\n    this.position = 0;\n  };\n  /**\n   * Get string representation of buffer and it's state.\n   * @return {string} Buffer as a string\n   */\n  BaseBuffer.prototype.toString = function () {\n    return this.constructor.name + '( position=' + this.position + ' )\\n  ' + this.toHex();\n  };\n  /**\n   * Get string representation of buffer.\n   * @return {string} Buffer as a string\n   */\n  BaseBuffer.prototype.toHex = function () {\n    var out = '';\n    for (var i = 0; i < this.length; i++) {\n      var hexByte = this.getUInt8(i).toString(16);\n      if (hexByte.length === 1) {\n        hexByte = '0' + hexByte;\n      }\n      out += hexByte;\n      if (i !== this.length - 1) {\n        out += ' ';\n      }\n    }\n    return out;\n  };\n  return BaseBuffer;\n}();\nexports.default = BaseBuffer;\n/**\n * Represents a view as slice of another buffer.\n * @access private\n */\nvar SliceBuffer = /** @class */function (_super) {\n  __extends(SliceBuffer, _super);\n  function SliceBuffer(start, length, inner) {\n    var _this = _super.call(this, length) || this;\n    _this._start = start;\n    _this._inner = inner;\n    return _this;\n  }\n  SliceBuffer.prototype.putUInt8 = function (position, val) {\n    this._inner.putUInt8(this._start + position, val);\n  };\n  SliceBuffer.prototype.getUInt8 = function (position) {\n    return this._inner.getUInt8(this._start + position);\n  };\n  SliceBuffer.prototype.putInt8 = function (position, val) {\n    this._inner.putInt8(this._start + position, val);\n  };\n  SliceBuffer.prototype.putFloat64 = function (position, val) {\n    this._inner.putFloat64(this._start + position, val);\n  };\n  SliceBuffer.prototype.getInt8 = function (position) {\n    return this._inner.getInt8(this._start + position);\n  };\n  SliceBuffer.prototype.getFloat64 = function (position) {\n    return this._inner.getFloat64(this._start + position);\n  };\n  return SliceBuffer;\n}(BaseBuffer);","map":null,"metadata":{},"sourceType":"script"}