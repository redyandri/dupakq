{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar _a = neo4j_driver_core_1.internal.constants,\n  ACCESS_MODE_READ = _a.ACCESS_MODE_READ,\n  FETCH_ALL = _a.FETCH_ALL,\n  assertString = neo4j_driver_core_1.internal.util.assertString;\n/* eslint-disable no-unused-vars */\n// Signature bytes for each request message type\nvar INIT = 0x01; // 0000 0001 // INIT <user_agent> <authentication_token>\nvar ACK_FAILURE = 0x0e; // 0000 1110 // ACK_FAILURE - unused\nvar RESET = 0x0f; // 0000 1111 // RESET\nvar RUN = 0x10; // 0001 0000 // RUN <query> <parameters>\nvar DISCARD_ALL = 0x2f; // 0010 1111 // DISCARD_ALL - unused\nvar PULL_ALL = 0x3f; // 0011 1111 // PULL_ALL\nvar HELLO = 0x01; // 0000 0001 // HELLO <metadata>\nvar GOODBYE = 0x02; // 0000 0010 // GOODBYE\nvar BEGIN = 0x11; // 0001 0001 // BEGIN <metadata>\nvar COMMIT = 0x12; // 0001 0010 // COMMIT\nvar ROLLBACK = 0x13; // 0001 0011 // ROLLBACK\nvar ROUTE = 0x66; // 0110 0110 // ROUTE\nvar DISCARD = 0x2f; // 0010 1111 // DISCARD\nvar PULL = 0x3f; // 0011 1111 // PULL\nvar READ_MODE = 'r';\n/* eslint-enable no-unused-vars */\nvar NO_STATEMENT_ID = -1;\nvar RequestMessage = /** @class */function () {\n  function RequestMessage(signature, fields, toString) {\n    this.signature = signature;\n    this.fields = fields;\n    this.toString = toString;\n  }\n  /**\n   * Create a new INIT message.\n   * @param {string} clientName the client name.\n   * @param {Object} authToken the authentication token.\n   * @return {RequestMessage} new INIT message.\n   */\n  RequestMessage.init = function (clientName, authToken) {\n    return new RequestMessage(INIT, [clientName, authToken], function () {\n      return \"INIT \" + clientName + \" {...}\";\n    });\n  };\n  /**\n   * Create a new RUN message.\n   * @param {string} query the cypher query.\n   * @param {Object} parameters the query parameters.\n   * @return {RequestMessage} new RUN message.\n   */\n  RequestMessage.run = function (query, parameters) {\n    return new RequestMessage(RUN, [query, parameters], function () {\n      return \"RUN \" + query + \" \" + neo4j_driver_core_1.json.stringify(parameters);\n    });\n  };\n  /**\n   * Get a PULL_ALL message.\n   * @return {RequestMessage} the PULL_ALL message.\n   */\n  RequestMessage.pullAll = function () {\n    return PULL_ALL_MESSAGE;\n  };\n  /**\n   * Get a RESET message.\n   * @return {RequestMessage} the RESET message.\n   */\n  RequestMessage.reset = function () {\n    return RESET_MESSAGE;\n  };\n  /**\n   * Create a new HELLO message.\n   * @param {string} userAgent the user agent.\n   * @param {Object} authToken the authentication token.\n   * @param {Object} optional server side routing, set to routing context to turn on server side routing (> 4.1)\n   * @return {RequestMessage} new HELLO message.\n   */\n  RequestMessage.hello = function (userAgent, authToken, routing, patchs) {\n    if (routing === void 0) {\n      routing = null;\n    }\n    if (patchs === void 0) {\n      patchs = null;\n    }\n    var metadata = Object.assign({\n      user_agent: userAgent\n    }, authToken);\n    if (routing) {\n      metadata.routing = routing;\n    }\n    if (patchs) {\n      metadata.patch_bolt = patchs;\n    }\n    return new RequestMessage(HELLO, [metadata], function () {\n      return \"HELLO {user_agent: '\" + userAgent + \"', ...}\";\n    });\n  };\n  /**\n   * Create a new BEGIN message.\n   * @param {Bookmark} bookmark the bookmark.\n   * @param {TxConfig} txConfig the configuration.\n   * @param {string} database the database name.\n   * @param {string} mode the access mode.\n   * @param {string} impersonatedUser the impersonated user.\n   * @return {RequestMessage} new BEGIN message.\n   */\n  RequestMessage.begin = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      bookmark = _b.bookmark,\n      txConfig = _b.txConfig,\n      database = _b.database,\n      mode = _b.mode,\n      impersonatedUser = _b.impersonatedUser;\n    var metadata = buildTxMetadata(bookmark, txConfig, database, mode, impersonatedUser);\n    return new RequestMessage(BEGIN, [metadata], function () {\n      return \"BEGIN \" + neo4j_driver_core_1.json.stringify(metadata);\n    });\n  };\n  /**\n   * Get a COMMIT message.\n   * @return {RequestMessage} the COMMIT message.\n   */\n  RequestMessage.commit = function () {\n    return COMMIT_MESSAGE;\n  };\n  /**\n   * Get a ROLLBACK message.\n   * @return {RequestMessage} the ROLLBACK message.\n   */\n  RequestMessage.rollback = function () {\n    return ROLLBACK_MESSAGE;\n  };\n  /**\n   * Create a new RUN message with additional metadata.\n   * @param {string} query the cypher query.\n   * @param {Object} parameters the query parameters.\n   * @param {Bookmark} bookmark the bookmark.\n   * @param {TxConfig} txConfig the configuration.\n   * @param {string} database the database name.\n   * @param {string} mode the access mode.\n   * @param {string} impersonatedUser the impersonated user.\n   * @return {RequestMessage} new RUN message with additional metadata.\n   */\n  RequestMessage.runWithMetadata = function (query, parameters, _a) {\n    var _b = _a === void 0 ? {} : _a,\n      bookmark = _b.bookmark,\n      txConfig = _b.txConfig,\n      database = _b.database,\n      mode = _b.mode,\n      impersonatedUser = _b.impersonatedUser;\n    var metadata = buildTxMetadata(bookmark, txConfig, database, mode, impersonatedUser);\n    return new RequestMessage(RUN, [query, parameters, metadata], function () {\n      return \"RUN \" + query + \" \" + neo4j_driver_core_1.json.stringify(parameters) + \" \" + neo4j_driver_core_1.json.stringify(metadata);\n    });\n  };\n  /**\n   * Get a GOODBYE message.\n   * @return {RequestMessage} the GOODBYE message.\n   */\n  RequestMessage.goodbye = function () {\n    return GOODBYE_MESSAGE;\n  };\n  /**\n   * Generates a new PULL message with additional metadata.\n   * @param {Integer|number} stmtId\n   * @param {Integer|number} n\n   * @return {RequestMessage} the PULL message.\n   */\n  RequestMessage.pull = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.stmtId,\n      stmtId = _c === void 0 ? NO_STATEMENT_ID : _c,\n      _d = _b.n,\n      n = _d === void 0 ? FETCH_ALL : _d;\n    var metadata = buildStreamMetadata(stmtId === null || stmtId === undefined ? NO_STATEMENT_ID : stmtId, n || FETCH_ALL);\n    return new RequestMessage(PULL, [metadata], function () {\n      return \"PULL \" + neo4j_driver_core_1.json.stringify(metadata);\n    });\n  };\n  /**\n   * Generates a new DISCARD message with additional metadata.\n   * @param {Integer|number} stmtId\n   * @param {Integer|number} n\n   * @return {RequestMessage} the PULL message.\n   */\n  RequestMessage.discard = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.stmtId,\n      stmtId = _c === void 0 ? NO_STATEMENT_ID : _c,\n      _d = _b.n,\n      n = _d === void 0 ? FETCH_ALL : _d;\n    var metadata = buildStreamMetadata(stmtId === null || stmtId === undefined ? NO_STATEMENT_ID : stmtId, n || FETCH_ALL);\n    return new RequestMessage(DISCARD, [metadata], function () {\n      return \"DISCARD \" + neo4j_driver_core_1.json.stringify(metadata);\n    });\n  };\n  /**\n   * Generate the ROUTE message, this message is used to fetch the routing table from the server\n   *\n   * @param {object} routingContext The routing context used to define the routing table. Multi-datacenter deployments is one of its use cases\n   * @param {string[]} bookmarks The list of the bookmark should be used\n   * @param {string} databaseName The name of the database to get the routing table for.\n   * @return {RequestMessage} the ROUTE message.\n   */\n  RequestMessage.route = function (routingContext, bookmarks, databaseName) {\n    if (routingContext === void 0) {\n      routingContext = {};\n    }\n    if (bookmarks === void 0) {\n      bookmarks = [];\n    }\n    if (databaseName === void 0) {\n      databaseName = null;\n    }\n    return new RequestMessage(ROUTE, [routingContext, bookmarks, databaseName], function () {\n      return \"ROUTE \" + neo4j_driver_core_1.json.stringify(routingContext) + \" \" + neo4j_driver_core_1.json.stringify(bookmarks) + \" \" + databaseName;\n    });\n  };\n  /**\n   * Generate the ROUTE message, this message is used to fetch the routing table from the server\n   *\n   * @param {object} routingContext The routing context used to define the routing table. Multi-datacenter deployments is one of its use cases\n   * @param {string[]} bookmarks The list of the bookmark should be used\n   * @param {object} databaseContext The context inforamtion of the database to get the routing table for.\n   * @param {string} databaseContext.databaseName The name of the database to get the routing table.\n   * @param {string} databaseContext.impersonatedUser The name of the user to impersonation when getting the routing table.\n   * @return {RequestMessage} the ROUTE message.\n   */\n  RequestMessage.routeV4x4 = function (routingContext, bookmarks, databaseContext) {\n    if (routingContext === void 0) {\n      routingContext = {};\n    }\n    if (bookmarks === void 0) {\n      bookmarks = [];\n    }\n    if (databaseContext === void 0) {\n      databaseContext = {};\n    }\n    var dbContext = {};\n    if (databaseContext.databaseName) {\n      dbContext.db = databaseContext.databaseName;\n    }\n    if (databaseContext.impersonatedUser) {\n      dbContext.imp_user = databaseContext.impersonatedUser;\n    }\n    return new RequestMessage(ROUTE, [routingContext, bookmarks, dbContext], function () {\n      return \"ROUTE \" + neo4j_driver_core_1.json.stringify(routingContext) + \" \" + neo4j_driver_core_1.json.stringify(bookmarks) + \" \" + neo4j_driver_core_1.json.stringify(dbContext);\n    });\n  };\n  return RequestMessage;\n}();\nexports.default = RequestMessage;\n/**\n * Create an object that represent transaction metadata.\n * @param {Bookmark} bookmark the bookmark.\n * @param {TxConfig} txConfig the configuration.\n * @param {string} database the database name.\n * @param {string} mode the access mode.\n * @param {string} impersonatedUser the impersonated user mode.\n * @return {Object} a metadata object.\n */\nfunction buildTxMetadata(bookmark, txConfig, database, mode, impersonatedUser) {\n  var metadata = {};\n  if (!bookmark.isEmpty()) {\n    metadata.bookmarks = bookmark.values();\n  }\n  if (txConfig.timeout) {\n    metadata.tx_timeout = txConfig.timeout;\n  }\n  if (txConfig.metadata) {\n    metadata.tx_metadata = txConfig.metadata;\n  }\n  if (database) {\n    metadata.db = assertString(database, 'database');\n  }\n  if (impersonatedUser) {\n    metadata.imp_user = assertString(impersonatedUser, 'impersonatedUser');\n  }\n  if (mode === ACCESS_MODE_READ) {\n    metadata.mode = READ_MODE;\n  }\n  return metadata;\n}\n/**\n * Create an object that represents streaming metadata.\n * @param {Integer|number} stmtId The query id to stream its results.\n * @param {Integer|number} n The number of records to stream.\n * @returns {Object} a metadata object.\n */\nfunction buildStreamMetadata(stmtId, n) {\n  var metadata = {\n    n: (0, neo4j_driver_core_1.int)(n)\n  };\n  if (stmtId !== NO_STATEMENT_ID) {\n    metadata.qid = (0, neo4j_driver_core_1.int)(stmtId);\n  }\n  return metadata;\n}\n// constants for messages that never change\nvar PULL_ALL_MESSAGE = new RequestMessage(PULL_ALL, [], function () {\n  return 'PULL_ALL';\n});\nvar RESET_MESSAGE = new RequestMessage(RESET, [], function () {\n  return 'RESET';\n});\nvar COMMIT_MESSAGE = new RequestMessage(COMMIT, [], function () {\n  return 'COMMIT';\n});\nvar ROLLBACK_MESSAGE = new RequestMessage(ROLLBACK, [], function () {\n  return 'ROLLBACK';\n});\nvar GOODBYE_MESSAGE = new RequestMessage(GOODBYE, [], function () {\n  return 'GOODBYE';\n});","map":null,"metadata":{},"sourceType":"script"}