{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toString = exports.toNumber = exports.inSafeRange = exports.isInt = exports.int = void 0;\n// 64-bit Integer library, originally from Long.js by dcodeIO\n// https://github.com/dcodeIO/Long.js\n// License Apache 2\nvar error_1 = require(\"./error\");\n/**\n * A cache of the Integer representations of small integer values.\n * @type {!Object}\n * @inner\n * @private\n */\n// eslint-disable-next-line no-use-before-define\nvar INT_CACHE = new Map();\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n * See exported functions for more convenient ways of operating integers.\n * Use `int()` function to create new integers, `isInt()` to check if given object is integer,\n * `inSafeRange()` to check if it is safe to convert given value to native number,\n * `toNumber()` and `toString()` to convert given integer to number or string respectively.\n * @access public\n * @exports Integer\n * @class A Integer class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n *\n * @constructor\n */\nvar Integer = /** @class */function () {\n  function Integer(low, high) {\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     * @expose\n     */\n    this.low = low || 0;\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     * @expose\n     */\n    this.high = high || 0;\n  }\n  // The internal representation of an Integer is the two given signed, 32-bit values.\n  // We use 32-bit pieces because these are the size of integers on which\n  // JavaScript performs bit-operations.  For operations like addition and\n  // multiplication, we split each number into 16 bit pieces, which can easily be\n  // multiplied within JavaScript's floating-point representation without overflow\n  // or change in sign.\n  //\n  // In the algorithms below, we frequently reduce the negative case to the\n  // positive case by negating the input(s) and then post-processing the result.\n  // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n  // a positive number, it overflows back into a negative).  Not handling this\n  // case would often result in infinite recursion.\n  //\n  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n  // methods on which they depend.\n  Integer.prototype.inSafeRange = function () {\n    return this.greaterThanOrEqual(Integer.MIN_SAFE_VALUE) && this.lessThanOrEqual(Integer.MAX_SAFE_VALUE);\n  };\n  /**\n   * Converts the Integer to an exact javascript Number, assuming it is a 32 bit integer.\n   * @returns {number}\n   * @expose\n   */\n  Integer.prototype.toInt = function () {\n    return this.low;\n  };\n  /**\n   * Converts the Integer to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n   * @returns {number}\n   * @expose\n   */\n  Integer.prototype.toNumber = function () {\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n  };\n  /**\n   * Converts the Integer to a BigInt representation of this value\n   * @returns {bigint}\n   * @expose\n   */\n  Integer.prototype.toBigInt = function () {\n    if (this.isZero()) {\n      return BigInt(0);\n    } else if (this.isPositive()) {\n      return BigInt(this.high >>> 0) * BigInt(TWO_PWR_32_DBL) + BigInt(this.low >>> 0);\n    } else {\n      var negate = this.negate();\n      return BigInt(-1) * (BigInt(negate.high >>> 0) * BigInt(TWO_PWR_32_DBL) + BigInt(negate.low >>> 0));\n    }\n  };\n  /**\n   * Converts the Integer to native number or -Infinity/+Infinity when it does not fit.\n   * @return {number}\n   * @package\n   */\n  Integer.prototype.toNumberOrInfinity = function () {\n    if (this.lessThan(Integer.MIN_SAFE_VALUE)) {\n      return Number.NEGATIVE_INFINITY;\n    } else if (this.greaterThan(Integer.MAX_SAFE_VALUE)) {\n      return Number.POSITIVE_INFINITY;\n    } else {\n      return this.toNumber();\n    }\n  };\n  /**\n   * Converts the Integer to a string written in the specified radix.\n   * @param {number=} radix Radix (2-36), defaults to 10\n   * @returns {string}\n   * @override\n   * @throws {RangeError} If `radix` is out of range\n   * @expose\n   */\n  Integer.prototype.toString = function (radix) {\n    radix = radix || 10;\n    if (radix < 2 || radix > 36) {\n      throw RangeError('radix out of range: ' + radix);\n    }\n    if (this.isZero()) {\n      return '0';\n    }\n    var rem;\n    if (this.isNegative()) {\n      if (this.equals(Integer.MIN_VALUE)) {\n        // We need to change the Integer value before it can be negated, so we remove\n        // the bottom-most digit in this base and then recurse to do the rest.\n        var radixInteger = Integer.fromNumber(radix);\n        var div = this.div(radixInteger);\n        rem = div.multiply(radixInteger).subtract(this);\n        return div.toString(radix) + rem.toInt().toString(radix);\n      } else {\n        return '-' + this.negate().toString(radix);\n      }\n    }\n    // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = Integer.fromNumber(Math.pow(radix, 6));\n    rem = this;\n    var result = '';\n    while (true) {\n      var remDiv = rem.div(radixToPower);\n      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0;\n      var digits = intval.toString(radix);\n      rem = remDiv;\n      if (rem.isZero()) {\n        return digits + result;\n      } else {\n        while (digits.length < 6) {\n          digits = '0' + digits;\n        }\n        result = '' + digits + result;\n      }\n    }\n  };\n  /**\n   * Gets the high 32 bits as a signed integer.\n   * @returns {number} Signed high bits\n   * @expose\n   */\n  Integer.prototype.getHighBits = function () {\n    return this.high;\n  };\n  /**\n   * Gets the low 32 bits as a signed integer.\n   * @returns {number} Signed low bits\n   * @expose\n   */\n  Integer.prototype.getLowBits = function () {\n    return this.low;\n  };\n  /**\n   * Gets the number of bits needed to represent the absolute value of this Integer.\n   * @returns {number}\n   * @expose\n   */\n  Integer.prototype.getNumBitsAbs = function () {\n    if (this.isNegative()) {\n      return this.equals(Integer.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();\n    }\n    var val = this.high !== 0 ? this.high : this.low;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & 1 << bit) !== 0) {\n        break;\n      }\n    }\n    return this.high !== 0 ? bit + 33 : bit + 1;\n  };\n  /**\n   * Tests if this Integer's value equals zero.\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.isZero = function () {\n    return this.high === 0 && this.low === 0;\n  };\n  /**\n   * Tests if this Integer's value is negative.\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.isNegative = function () {\n    return this.high < 0;\n  };\n  /**\n   * Tests if this Integer's value is positive.\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.isPositive = function () {\n    return this.high >= 0;\n  };\n  /**\n   * Tests if this Integer's value is odd.\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.isOdd = function () {\n    return (this.low & 1) === 1;\n  };\n  /**\n   * Tests if this Integer's value is even.\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.isEven = function () {\n    return (this.low & 1) === 0;\n  };\n  /**\n   * Tests if this Integer's value equals the specified's.\n   * @param {!Integer|number|string} other Other value\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.equals = function (other) {\n    var theOther = Integer.fromValue(other);\n    return this.high === theOther.high && this.low === theOther.low;\n  };\n  /**\n   * Tests if this Integer's value differs from the specified's.\n   * @param {!Integer|number|string} other Other value\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.notEquals = function (other) {\n    return !this.equals( /* validates */other);\n  };\n  /**\n   * Tests if this Integer's value is less than the specified's.\n   * @param {!Integer|number|string} other Other value\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.lessThan = function (other) {\n    return this.compare( /* validates */other) < 0;\n  };\n  /**\n   * Tests if this Integer's value is less than or equal the specified's.\n   * @param {!Integer|number|string} other Other value\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.lessThanOrEqual = function (other) {\n    return this.compare( /* validates */other) <= 0;\n  };\n  /**\n   * Tests if this Integer's value is greater than the specified's.\n   * @param {!Integer|number|string} other Other value\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.greaterThan = function (other) {\n    return this.compare( /* validates */other) > 0;\n  };\n  /**\n   * Tests if this Integer's value is greater than or equal the specified's.\n   * @param {!Integer|number|string} other Other value\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.prototype.greaterThanOrEqual = function (other) {\n    return this.compare( /* validates */other) >= 0;\n  };\n  /**\n   * Compares this Integer's value with the specified's.\n   * @param {!Integer|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   * @expose\n   */\n  Integer.prototype.compare = function (other) {\n    var theOther = Integer.fromValue(other);\n    if (this.equals(theOther)) {\n      return 0;\n    }\n    var thisNeg = this.isNegative();\n    var otherNeg = theOther.isNegative();\n    if (thisNeg && !otherNeg) {\n      return -1;\n    }\n    if (!thisNeg && otherNeg) {\n      return 1;\n    }\n    // At this point the sign bits are the same\n    return this.subtract(theOther).isNegative() ? -1 : 1;\n  };\n  /**\n   * Negates this Integer's value.\n   * @returns {!Integer} Negated Integer\n   * @expose\n   */\n  Integer.prototype.negate = function () {\n    if (this.equals(Integer.MIN_VALUE)) {\n      return Integer.MIN_VALUE;\n    }\n    return this.not().add(Integer.ONE);\n  };\n  /**\n   * Returns the sum of this and the specified Integer.\n   * @param {!Integer|number|string} addend Addend\n   * @returns {!Integer} Sum\n   * @expose\n   */\n  Integer.prototype.add = function (addend) {\n    var theAddend = Integer.fromValue(addend);\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xffff;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xffff;\n    var b48 = theAddend.high >>> 16;\n    var b32 = theAddend.high & 0xffff;\n    var b16 = theAddend.low >>> 16;\n    var b00 = theAddend.low & 0xffff;\n    var c48 = 0;\n    var c32 = 0;\n    var c16 = 0;\n    var c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xffff;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xffff;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xffff;\n    c48 += a48 + b48;\n    c48 &= 0xffff;\n    return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);\n  };\n  /**\n   * Returns the difference of this and the specified Integer.\n   * @param {!Integer|number|string} subtrahend Subtrahend\n   * @returns {!Integer} Difference\n   * @expose\n   */\n  Integer.prototype.subtract = function (subtrahend) {\n    var theSubtrahend = Integer.fromValue(subtrahend);\n    return this.add(theSubtrahend.negate());\n  };\n  /**\n   * Returns the product of this and the specified Integer.\n   * @param {!Integer|number|string} multiplier Multiplier\n   * @returns {!Integer} Product\n   * @expose\n   */\n  Integer.prototype.multiply = function (multiplier) {\n    if (this.isZero()) {\n      return Integer.ZERO;\n    }\n    var theMultiplier = Integer.fromValue(multiplier);\n    if (theMultiplier.isZero()) {\n      return Integer.ZERO;\n    }\n    if (this.equals(Integer.MIN_VALUE)) {\n      return theMultiplier.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;\n    }\n    if (theMultiplier.equals(Integer.MIN_VALUE)) {\n      return this.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;\n    }\n    if (this.isNegative()) {\n      if (theMultiplier.isNegative()) {\n        return this.negate().multiply(theMultiplier.negate());\n      } else {\n        return this.negate().multiply(theMultiplier).negate();\n      }\n    } else if (theMultiplier.isNegative()) {\n      return this.multiply(theMultiplier.negate()).negate();\n    }\n    // If both longs are small, use float multiplication\n    if (this.lessThan(TWO_PWR_24) && theMultiplier.lessThan(TWO_PWR_24)) {\n      return Integer.fromNumber(this.toNumber() * theMultiplier.toNumber());\n    }\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xffff;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xffff;\n    var b48 = theMultiplier.high >>> 16;\n    var b32 = theMultiplier.high & 0xffff;\n    var b16 = theMultiplier.low >>> 16;\n    var b00 = theMultiplier.low & 0xffff;\n    var c48 = 0;\n    var c32 = 0;\n    var c16 = 0;\n    var c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xffff;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xffff;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xffff;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xffff;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xffff;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xffff;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xffff;\n    return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);\n  };\n  /**\n   * Returns this Integer divided by the specified.\n   * @param {!Integer|number|string} divisor Divisor\n   * @returns {!Integer} Quotient\n   * @expose\n   */\n  Integer.prototype.div = function (divisor) {\n    var theDivisor = Integer.fromValue(divisor);\n    if (theDivisor.isZero()) {\n      throw (0, error_1.newError)('division by zero');\n    }\n    if (this.isZero()) {\n      return Integer.ZERO;\n    }\n    var approx, rem, res;\n    if (this.equals(Integer.MIN_VALUE)) {\n      if (theDivisor.equals(Integer.ONE) || theDivisor.equals(Integer.NEG_ONE)) {\n        return Integer.MIN_VALUE;\n      }\n      if (theDivisor.equals(Integer.MIN_VALUE)) {\n        return Integer.ONE;\n      } else {\n        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n        var halfThis = this.shiftRight(1);\n        approx = halfThis.div(theDivisor).shiftLeft(1);\n        if (approx.equals(Integer.ZERO)) {\n          return theDivisor.isNegative() ? Integer.ONE : Integer.NEG_ONE;\n        } else {\n          rem = this.subtract(theDivisor.multiply(approx));\n          res = approx.add(rem.div(theDivisor));\n          return res;\n        }\n      }\n    } else if (theDivisor.equals(Integer.MIN_VALUE)) {\n      return Integer.ZERO;\n    }\n    if (this.isNegative()) {\n      if (theDivisor.isNegative()) {\n        return this.negate().div(theDivisor.negate());\n      }\n      return this.negate().div(theDivisor).negate();\n    } else if (theDivisor.isNegative()) {\n      return this.div(theDivisor.negate()).negate();\n    }\n    // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n    res = Integer.ZERO;\n    rem = this;\n    while (rem.greaterThanOrEqual(theDivisor)) {\n      // Approximate the result of division. This may be a little greater or\n      // smaller than the actual value.\n      approx = Math.max(1, Math.floor(rem.toNumber() / theDivisor.toNumber()));\n      // We will tweak the approximate result by changing it in the 48-th digit or\n      // the smallest non-fractional digit, whichever is larger.\n      var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n      var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n      // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      var approxRes = Integer.fromNumber(approx);\n      var approxRem = approxRes.multiply(theDivisor);\n      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n        approx -= delta;\n        approxRes = Integer.fromNumber(approx);\n        approxRem = approxRes.multiply(theDivisor);\n      }\n      // We know the answer can't be zero... and actually, zero would cause\n      // infinite recursion since we would make no progress.\n      if (approxRes.isZero()) {\n        approxRes = Integer.ONE;\n      }\n      res = res.add(approxRes);\n      rem = rem.subtract(approxRem);\n    }\n    return res;\n  };\n  /**\n   * Returns this Integer modulo the specified.\n   * @param {!Integer|number|string} divisor Divisor\n   * @returns {!Integer} Remainder\n   * @expose\n   */\n  Integer.prototype.modulo = function (divisor) {\n    var theDivisor = Integer.fromValue(divisor);\n    return this.subtract(this.div(theDivisor).multiply(theDivisor));\n  };\n  /**\n   * Returns the bitwise NOT of this Integer.\n   * @returns {!Integer}\n   * @expose\n   */\n  Integer.prototype.not = function () {\n    return Integer.fromBits(~this.low, ~this.high);\n  };\n  /**\n   * Returns the bitwise AND of this Integer and the specified.\n   * @param {!Integer|number|string} other Other Integer\n   * @returns {!Integer}\n   * @expose\n   */\n  Integer.prototype.and = function (other) {\n    var theOther = Integer.fromValue(other);\n    return Integer.fromBits(this.low & theOther.low, this.high & theOther.high);\n  };\n  /**\n   * Returns the bitwise OR of this Integer and the specified.\n   * @param {!Integer|number|string} other Other Integer\n   * @returns {!Integer}\n   * @expose\n   */\n  Integer.prototype.or = function (other) {\n    var theOther = Integer.fromValue(other);\n    return Integer.fromBits(this.low | theOther.low, this.high | theOther.high);\n  };\n  /**\n   * Returns the bitwise XOR of this Integer and the given one.\n   * @param {!Integer|number|string} other Other Integer\n   * @returns {!Integer}\n   * @expose\n   */\n  Integer.prototype.xor = function (other) {\n    var theOther = Integer.fromValue(other);\n    return Integer.fromBits(this.low ^ theOther.low, this.high ^ theOther.high);\n  };\n  /**\n   * Returns this Integer with bits shifted to the left by the given amount.\n   * @param {number|!Integer} numBits Number of bits\n   * @returns {!Integer} Shifted Integer\n   * @expose\n   */\n  Integer.prototype.shiftLeft = function (numBits) {\n    var bitsCount = Integer.toNumber(numBits);\n    if ((bitsCount &= 63) === 0) {\n      return Integer.ZERO;\n    } else if (bitsCount < 32) {\n      return Integer.fromBits(this.low << bitsCount, this.high << bitsCount | this.low >>> 32 - bitsCount);\n    } else {\n      return Integer.fromBits(0, this.low << bitsCount - 32);\n    }\n  };\n  /**\n   * Returns this Integer with bits arithmetically shifted to the right by the given amount.\n   * @param {number|!Integer} numBits Number of bits\n   * @returns {!Integer} Shifted Integer\n   * @expose\n   */\n  Integer.prototype.shiftRight = function (numBits) {\n    var bitsCount = Integer.toNumber(numBits);\n    if ((bitsCount &= 63) === 0) {\n      return Integer.ZERO;\n    } else if (numBits < 32) {\n      return Integer.fromBits(this.low >>> bitsCount | this.high << 32 - bitsCount, this.high >> bitsCount);\n    } else {\n      return Integer.fromBits(this.high >> bitsCount - 32, this.high >= 0 ? 0 : -1);\n    }\n  };\n  /**\n   * Tests if the specified object is a Integer.\n   * @access private\n   * @param {*} obj Object\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.isInteger = function (obj) {\n    return (obj && obj.__isInteger__) === true;\n  };\n  /**\n   * Returns a Integer representing the given 32 bit integer value.\n   * @access private\n   * @param {number} value The 32 bit integer in question\n   * @returns {!Integer} The corresponding Integer value\n   * @expose\n   */\n  Integer.fromInt = function (value) {\n    var obj, cachedObj;\n    value = value | 0;\n    if (value >= -128 && value < 128) {\n      cachedObj = INT_CACHE.get(value);\n      if (cachedObj) {\n        return cachedObj;\n      }\n    }\n    obj = new Integer(value, value < 0 ? -1 : 0);\n    if (value >= -128 && value < 128) {\n      INT_CACHE.set(value, obj);\n    }\n    return obj;\n  };\n  /**\n   * Returns a Integer representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n   *  assumed to use 32 bits.\n   * @access private\n   * @param {number} lowBits The low 32 bits\n   * @param {number} highBits The high 32 bits\n   * @returns {!Integer} The corresponding Integer value\n   * @expose\n   */\n  Integer.fromBits = function (lowBits, highBits) {\n    return new Integer(lowBits, highBits);\n  };\n  /**\n   * Returns a Integer representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @access private\n   * @param {number} value The number in question\n   * @returns {!Integer} The corresponding Integer value\n   * @expose\n   */\n  Integer.fromNumber = function (value) {\n    if (isNaN(value) || !isFinite(value)) {\n      return Integer.ZERO;\n    }\n    if (value <= -TWO_PWR_63_DBL) {\n      return Integer.MIN_VALUE;\n    }\n    if (value + 1 >= TWO_PWR_63_DBL) {\n      return Integer.MAX_VALUE;\n    }\n    if (value < 0) {\n      return Integer.fromNumber(-value).negate();\n    }\n    return new Integer(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);\n  };\n  /**\n   * Returns a Integer representation of the given string, written using the specified radix.\n   * @access private\n   * @param {string} str The textual representation of the Integer\n   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n   * @param {Object} [opts={}] Configuration options\n   * @param {boolean} [opts.strictStringValidation=false] Enable strict validation generated Integer.\n   * @returns {!Integer} The corresponding Integer value\n   * @expose\n   */\n  Integer.fromString = function (str, radix, _a) {\n    var _b = _a === void 0 ? {} : _a,\n      strictStringValidation = _b.strictStringValidation;\n    if (str.length === 0) {\n      throw (0, error_1.newError)('number format error: empty string');\n    }\n    if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity') {\n      return Integer.ZERO;\n    }\n    radix = radix || 10;\n    if (radix < 2 || radix > 36) {\n      throw (0, error_1.newError)('radix out of range: ' + radix);\n    }\n    var p;\n    if ((p = str.indexOf('-')) > 0) {\n      throw (0, error_1.newError)('number format error: interior \"-\" character: ' + str);\n    } else if (p === 0) {\n      return Integer.fromString(str.substring(1), radix).negate();\n    }\n    // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = Integer.fromNumber(Math.pow(radix, 8));\n    var result = Integer.ZERO;\n    for (var i = 0; i < str.length; i += 8) {\n      var size = Math.min(8, str.length - i);\n      var valueString = str.substring(i, i + size);\n      var value = parseInt(valueString, radix);\n      if (strictStringValidation === true && !_isValidNumberFromString(valueString, value, radix)) {\n        throw (0, error_1.newError)(\"number format error: \\\"\" + valueString + \"\\\" is NaN in radix \" + radix + \": \" + str);\n      }\n      if (size < 8) {\n        var power = Integer.fromNumber(Math.pow(radix, size));\n        result = result.multiply(power).add(Integer.fromNumber(value));\n      } else {\n        result = result.multiply(radixToPower);\n        result = result.add(Integer.fromNumber(value));\n      }\n    }\n    return result;\n  };\n  /**\n   * Converts the specified value to a Integer.\n   * @access private\n   * @param {!Integer|number|string|bigint|!{low: number, high: number}} val Value\n   * @param {Object} [opts={}] Configuration options\n   * @param {boolean} [opts.strictStringValidation=false] Enable strict validation generated Integer.\n   * @returns {!Integer}\n   * @expose\n   */\n  Integer.fromValue = function (val, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    if (val /* is compatible */ instanceof Integer) {\n      return val;\n    }\n    if (typeof val === 'number') {\n      return Integer.fromNumber(val);\n    }\n    if (typeof val === 'string') {\n      return Integer.fromString(val, undefined, opts);\n    }\n    if (typeof val === 'bigint') {\n      return Integer.fromString(val.toString());\n    }\n    // Throws for non-objects, converts non-instanceof Integer:\n    return new Integer(val.low, val.high);\n  };\n  /**\n   * Converts the specified value to a number.\n   * @access private\n   * @param {!Integer|number|string|!{low: number, high: number}} val Value\n   * @returns {number}\n   * @expose\n   */\n  Integer.toNumber = function (val) {\n    switch (typeof val) {\n      case 'number':\n        return val;\n      case 'bigint':\n        return Number(val);\n      default:\n        return Integer.fromValue(val).toNumber();\n    }\n  };\n  /**\n   * Converts the specified value to a string.\n   * @access private\n   * @param {!Integer|number|string|!{low: number, high: number}} val Value\n   * @param {number} radix optional radix for string conversion, defaults to 10\n   * @returns {string}\n   * @expose\n   */\n  Integer.toString = function (val, radix) {\n    return Integer.fromValue(val).toString(radix);\n  };\n  /**\n   * Checks if the given value is in the safe range in order to be converted to a native number\n   * @access private\n   * @param {!Integer|number|string|!{low: number, high: number}} val Value\n   * @param {number} radix optional radix for string conversion, defaults to 10\n   * @returns {boolean}\n   * @expose\n   */\n  Integer.inSafeRange = function (val) {\n    return Integer.fromValue(val).inSafeRange();\n  };\n  /**\n   * Signed zero.\n   * @type {!Integer}\n   * @expose\n   */\n  Integer.ZERO = Integer.fromInt(0);\n  /**\n   * Signed one.\n   * @type {!Integer}\n   * @expose\n   */\n  Integer.ONE = Integer.fromInt(1);\n  /**\n   * Signed negative one.\n   * @type {!Integer}\n   * @expose\n   */\n  Integer.NEG_ONE = Integer.fromInt(-1);\n  /**\n   * Maximum signed value.\n   * @type {!Integer}\n   * @expose\n   */\n  Integer.MAX_VALUE = Integer.fromBits(0xffffffff | 0, 0x7fffffff | 0);\n  /**\n   * Minimum signed value.\n   * @type {!Integer}\n   * @expose\n   */\n  Integer.MIN_VALUE = Integer.fromBits(0, 0x80000000 | 0);\n  /**\n   * Minimum safe value.\n   * @type {!Integer}\n   * @expose\n   */\n  Integer.MIN_SAFE_VALUE = Integer.fromBits(0x1 | 0, 0xffffffffffe00000 | 0);\n  /**\n   * Maximum safe value.\n   * @type {!Integer}\n   * @expose\n   */\n  Integer.MAX_SAFE_VALUE = Integer.fromBits(0xffffffff | 0, 0x1fffff | 0);\n  /**\n   * An indicator used to reliably determine if an object is a Integer or not.\n   * @type {boolean}\n   * @const\n   * @expose\n   * @private\n   */\n  Integer.__isInteger__ = true;\n  return Integer;\n}();\n/**\n * @private\n * @param num\n * @param radix\n * @param minSize\n * @returns {string}\n */\nfunction _convertNumberToString(num, radix, minSize) {\n  var theNumberString = num.toString(radix);\n  var paddingLength = Math.max(minSize - theNumberString.length, 0);\n  var padding = '0'.repeat(paddingLength);\n  return \"\" + padding + theNumberString;\n}\n/**\n *\n * @private\n * @param theString\n * @param theNumber\n * @param radix\n * @return {boolean} True if valid\n */\nfunction _isValidNumberFromString(theString, theNumber, radix) {\n  return !Number.isNaN(theString) && !Number.isNaN(theNumber) && _convertNumberToString(theNumber, radix, theString.length) === theString.toLowerCase();\n}\nObject.defineProperty(Integer.prototype, '__isInteger__', {\n  value: true,\n  enumerable: false,\n  configurable: false\n});\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n/**\n * @type {!Integer}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_24 = Integer.fromInt(TWO_PWR_24_DBL);\n/**\n * Cast value to Integer type.\n * @access public\n * @param {Mixed} value - The value to use.\n * @param {Object} [opts={}] Configuration options\n * @param {boolean} [opts.strictStringValidation=false] Enable strict validation generated Integer.\n * @return {Integer} - An object of type Integer.\n */\nvar int = Integer.fromValue;\nexports.int = int;\n/**\n * Check if a variable is of Integer type.\n * @access public\n * @param {Mixed} value - The variable to check.\n * @return {Boolean} - Is it of the Integer type?\n */\nvar isInt = Integer.isInteger;\nexports.isInt = isInt;\n/**\n * Check if a variable can be safely converted to a number\n * @access public\n * @param {Mixed} value - The variable to check\n * @return {Boolean} - true if it is safe to call toNumber on variable otherwise false\n */\nvar inSafeRange = Integer.inSafeRange;\nexports.inSafeRange = inSafeRange;\n/**\n * Converts a variable to a number\n * @access public\n * @param {Mixed} value - The variable to convert\n * @return {number} - the variable as a number\n */\nvar toNumber = Integer.toNumber;\nexports.toNumber = toNumber;\n/**\n * Converts the integer to a string representation\n * @access public\n * @param {Mixed} value - The variable to convert\n * @param {number} radix - radix to use in string conversion, defaults to 10\n * @return {string} - returns a string representation of the integer\n */\nvar toString = Integer.toString;\nexports.toString = toString;\nexports.default = Integer;","map":null,"metadata":{},"sourceType":"script"}