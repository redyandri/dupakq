{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Unpacker = exports.Packer = void 0;\nvar v1 = __importStar(require(\"./packstream-v1\"));\nvar utc = __importStar(require(\"./packstream-utc\"));\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar temporal_factory_1 = require(\"./temporal-factory\");\nvar _a = neo4j_driver_core_1.internal.temporalUtil,\n  dateToEpochDay = _a.dateToEpochDay,\n  localDateTimeToEpochSecond = _a.localDateTimeToEpochSecond,\n  localTimeToNanoOfDay = _a.localTimeToNanoOfDay;\nvar POINT_2D = 0x58;\nvar POINT_2D_STRUCT_SIZE = 3;\nvar POINT_3D = 0x59;\nvar POINT_3D_STRUCT_SIZE = 4;\nvar DURATION = 0x45;\nvar DURATION_STRUCT_SIZE = 4;\nvar LOCAL_TIME = 0x74;\nvar LOCAL_TIME_STRUCT_SIZE = 1;\nvar TIME = 0x54;\nvar TIME_STRUCT_SIZE = 2;\nvar DATE = 0x44;\nvar DATE_STRUCT_SIZE = 1;\nvar LOCAL_DATE_TIME = 0x64;\nvar LOCAL_DATE_TIME_STRUCT_SIZE = 2;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x46;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x66;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\nvar Packer = /** @class */function (_super) {\n  __extends(Packer, _super);\n  function Packer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Packer.prototype.disableByteArrays = function () {\n    throw new Error('Bolt V2 should always support byte arrays');\n  };\n  Packer.prototype.packable = function (obj) {\n    var _this = this;\n    if ((0, neo4j_driver_core_1.isPoint)(obj)) {\n      return function () {\n        return packPoint(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDuration)(obj)) {\n      return function () {\n        return packDuration(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isLocalTime)(obj)) {\n      return function () {\n        return packLocalTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isTime)(obj)) {\n      return function () {\n        return packTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDate)(obj)) {\n      return function () {\n        return packDate(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isLocalDateTime)(obj)) {\n      return function () {\n        return packLocalDateTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDateTime)(obj) && this.useUtc) {\n      return function () {\n        return utc.packDateTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDateTime)(obj) && !this.useUtc) {\n      return function () {\n        return packDateTime(obj, _this);\n      };\n    } else {\n      return _super.prototype.packable.call(this, obj);\n    }\n  };\n  return Packer;\n}(v1.Packer);\nexports.Packer = Packer;\nvar Unpacker = /** @class */function (_super) {\n  __extends(Unpacker, _super);\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n   */\n  function Unpacker(disableLosslessIntegers, useBigInt) {\n    if (disableLosslessIntegers === void 0) {\n      disableLosslessIntegers = false;\n    }\n    if (useBigInt === void 0) {\n      useBigInt = false;\n    }\n    return _super.call(this, disableLosslessIntegers, useBigInt) || this;\n  }\n  Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n    if (signature === POINT_2D) {\n      return unpackPoint2D(this, structSize, buffer);\n    } else if (signature === POINT_3D) {\n      return unpackPoint3D(this, structSize, buffer);\n    } else if (signature === DURATION) {\n      return unpackDuration(this, structSize, buffer);\n    } else if (signature === LOCAL_TIME) {\n      return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === TIME) {\n      return unpackTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE) {\n      return unpackDate(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === LOCAL_DATE_TIME) {\n      return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === utc.DATE_TIME_WITH_ZONE_OFFSET && this.useUtc) {\n      return utc.unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE_TIME_WITH_ZONE_OFFSET && !this.useUtc) {\n      return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === utc.DATE_TIME_WITH_ZONE_ID && this.useUtc) {\n      return utc.unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE_TIME_WITH_ZONE_ID && !this.useUtc) {\n      return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else {\n      return _super.prototype._unpackUnknownStruct.call(this, signature, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    }\n  };\n  return Unpacker;\n}(v1.Unpacker);\nexports.Unpacker = Unpacker;\n/**\n * Pack given 2D or 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint(point, packer) {\n  var is2DPoint = point.z === null || point.z === undefined;\n  if (is2DPoint) {\n    packPoint2D(point, packer);\n  } else {\n    packPoint3D(point, packer);\n  }\n}\n/**\n * Pack given 2D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint2D(point, packer) {\n  var packableStructFields = [packer.packable((0, neo4j_driver_core_1.int)(point.srid)), packer.packable(point.x), packer.packable(point.y)];\n  packer.packStruct(POINT_2D, packableStructFields);\n}\n/**\n * Pack given 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint3D(point, packer) {\n  var packableStructFields = [packer.packable((0, neo4j_driver_core_1.int)(point.srid)), packer.packable(point.x), packer.packable(point.y), packer.packable(point.z)];\n  packer.packStruct(POINT_3D, packableStructFields);\n}\n/**\n * Unpack 2D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 2D point value.\n */\nfunction unpackPoint2D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);\n  return new neo4j_driver_core_1.Point(unpacker.unpack(buffer),\n  // srid\n  unpacker.unpack(buffer),\n  // x\n  unpacker.unpack(buffer),\n  // y\n  undefined // z\n  );\n}\n/**\n * Unpack 3D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 3D point value.\n */\nfunction unpackPoint3D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);\n  return new neo4j_driver_core_1.Point(unpacker.unpack(buffer),\n  // srid\n  unpacker.unpack(buffer),\n  // x\n  unpacker.unpack(buffer),\n  // y\n  unpacker.unpack(buffer) // z\n  );\n}\n/**\n * Pack given duration.\n * @param {Duration} value the duration value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDuration(value, packer) {\n  var months = (0, neo4j_driver_core_1.int)(value.months);\n  var days = (0, neo4j_driver_core_1.int)(value.days);\n  var seconds = (0, neo4j_driver_core_1.int)(value.seconds);\n  var nanoseconds = (0, neo4j_driver_core_1.int)(value.nanoseconds);\n  var packableStructFields = [packer.packable(months), packer.packable(days), packer.packable(seconds), packer.packable(nanoseconds)];\n  packer.packStruct(DURATION, packableStructFields);\n}\n/**\n * Unpack duration value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Duration} the unpacked duration value.\n */\nfunction unpackDuration(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);\n  var months = unpacker.unpack(buffer);\n  var days = unpacker.unpack(buffer);\n  var seconds = unpacker.unpack(buffer);\n  var nanoseconds = unpacker.unpack(buffer);\n  return new neo4j_driver_core_1.Duration(months, days, seconds, nanoseconds);\n}\n/**\n * Pack given local time.\n * @param {LocalTime} value the local time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packLocalTime(value, packer) {\n  var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n  var packableStructFields = [packer.packable(nanoOfDay)];\n  packer.packStruct(LOCAL_TIME, packableStructFields);\n}\n/**\n * Unpack local time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.\n * @return {LocalTime} the unpacked local time value.\n */\nfunction unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given time.\n * @param {Time} value the time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packTime(value, packer) {\n  var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n  var offsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(nanoOfDay), packer.packable(offsetSeconds)];\n  packer.packStruct(TIME, packableStructFields);\n}\n/**\n * Unpack time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.\n * @return {Time} the unpacked time value.\n */\nfunction unpackTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var offsetSeconds = unpacker.unpackInteger(buffer);\n  var localTime = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n  var result = new neo4j_driver_core_1.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given neo4j date.\n * @param {Date} value the date value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDate(value, packer) {\n  var epochDay = dateToEpochDay(value.year, value.month, value.day);\n  var packableStructFields = [packer.packable(epochDay)];\n  packer.packStruct(DATE, packableStructFields);\n}\n/**\n * Unpack neo4j date value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.\n * @return {Date} the unpacked neo4j date value.\n */\nfunction unpackDate(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);\n  var epochDay = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.epochDayToDate)(epochDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given local date time.\n * @param {LocalDateTime} value the local date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packLocalDateTime(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano)];\n  packer.packStruct(LOCAL_DATE_TIME, packableStructFields);\n}\n/**\n * Unpack local date time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.\n * @return {LocalDateTime} the unpacked local date time value.\n */\nfunction unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given date time.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTime(value, packer) {\n  if (value.timeZoneId) {\n    packDateTimeWithZoneId(value, packer);\n  } else {\n    packDateTimeWithZoneOffset(value, packer);\n  }\n}\n/**\n * Pack given date time with zone offset.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTimeWithZoneOffset(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneOffsetSeconds)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);\n}\n/**\n * Unpack date time with zone offset value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone offset value.\n */\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\n  var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given date time with zone id.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTimeWithZoneId(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var timeZoneId = value.timeZoneId;\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneId)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);\n}\n/**\n * Unpack date time with zone id value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone id value.\n */\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneId = unpacker.unpack(buffer);\n  var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n  if (!disableLosslessIntegers && !useBigInt) {\n    return obj;\n  }\n  var convert = function convert(value) {\n    return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n  };\n  var clone = Object.create(Object.getPrototypeOf(obj));\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      var value = obj[prop];\n      clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n    }\n  }\n  Object.freeze(clone);\n  return clone;\n}","map":null,"metadata":{},"sourceType":"script"}