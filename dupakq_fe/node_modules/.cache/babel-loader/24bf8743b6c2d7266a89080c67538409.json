{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2]) _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar pool_config_1 = __importDefault(require(\"./pool-config\"));\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar Logger = neo4j_driver_core_1.internal.logger.Logger;\nvar Pool = /** @class */function () {\n  /**\n   * @param {function(address: ServerAddress, function(address: ServerAddress, resource: object): Promise<object>): Promise<object>} create\n   *                an allocation function that creates a promise with a new resource. It's given an address for which to\n   *                allocate the connection and a function that will return the resource to the pool if invoked, which is\n   *                meant to be called on .dispose or .close or whatever mechanism the resource uses to finalize.\n   * @param {function(resource: object): Promise<void>} destroy\n   *                called with the resource when it is evicted from this pool\n   * @param {function(resource: object): boolean} validate\n   *                called at various times (like when an instance is acquired and when it is returned.\n   *                If this returns false, the resource will be evicted\n   * @param {function(resource: object, observer: { onError }): void} installIdleObserver\n   *                called when the resource is released back to pool\n   * @param {function(resource: object): void} removeIdleObserver\n   *                called when the resource is acquired from the pool\n   * @param {PoolConfig} config configuration for the new driver.\n   * @param {Logger} log the driver logger.\n   */\n  function Pool(_a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.create,\n      create = _c === void 0 ? function (address, release) {\n        return Promise.resolve();\n      } : _c,\n      _d = _b.destroy,\n      destroy = _d === void 0 ? function (conn) {\n        return Promise.resolve();\n      } : _d,\n      _e = _b.validate,\n      validate = _e === void 0 ? function (conn) {\n        return true;\n      } : _e,\n      _f = _b.installIdleObserver,\n      installIdleObserver = _f === void 0 ? function (conn, observer) {} : _f,\n      _g = _b.removeIdleObserver,\n      removeIdleObserver = _g === void 0 ? function (conn) {} : _g,\n      _h = _b.config,\n      config = _h === void 0 ? pool_config_1.default.defaultConfig() : _h,\n      _j = _b.log,\n      log = _j === void 0 ? Logger.noOp() : _j;\n    this._create = create;\n    this._destroy = destroy;\n    this._validate = validate;\n    this._installIdleObserver = installIdleObserver;\n    this._removeIdleObserver = removeIdleObserver;\n    this._maxSize = config.maxSize;\n    this._acquisitionTimeout = config.acquisitionTimeout;\n    this._pools = {};\n    this._pendingCreates = {};\n    this._acquireRequests = {};\n    this._activeResourceCounts = {};\n    this._poolState = {};\n    this._release = this._release.bind(this);\n    this._log = log;\n    this._closed = false;\n  }\n  /**\n   * Acquire and idle resource fom the pool or create a new one.\n   * @param {ServerAddress} address the address for which we're acquiring.\n   * @return {Object} resource that is ready to use.\n   */\n  Pool.prototype.acquire = function (address) {\n    var _this = this;\n    return this._acquire(address).then(function (resource) {\n      var key = address.asKey();\n      if (resource) {\n        // New or existing resource acquired\n        return resource;\n      }\n      // We're out of resources and will try to acquire later on when an existing resource is released.\n      var allRequests = _this._acquireRequests;\n      var requests = allRequests[key];\n      if (!requests) {\n        allRequests[key] = [];\n      }\n      return new Promise(function (resolve, reject) {\n        var request;\n        var timeoutId = setTimeout(function () {\n          // acquisition timeout fired\n          // remove request from the queue of pending requests, if it's still there\n          // request might've been taken out by the release operation\n          var pendingRequests = allRequests[key];\n          if (pendingRequests) {\n            allRequests[key] = pendingRequests.filter(function (item) {\n              return item !== request;\n            });\n          }\n          if (request.isCompleted()) {\n            // request already resolved/rejected by the release operation; nothing to do\n          } else {\n            // request is still pending and needs to be failed\n            var activeCount = _this.activeResourceCount(address);\n            var idleCount = _this.has(address) ? _this._pools[key].length : 0;\n            request.reject((0, neo4j_driver_core_1.newError)(\"Connection acquisition timed out in \" + _this._acquisitionTimeout + \" ms. Pool status: Active conn count = \" + activeCount + \", Idle conn count = \" + idleCount + \".\"));\n          }\n        }, _this._acquisitionTimeout);\n        request = new PendingRequest(key, resolve, reject, timeoutId, _this._log);\n        allRequests[key].push(request);\n      });\n    });\n  };\n  /**\n   * Destroy all idle resources for the given address.\n   * @param {ServerAddress} address the address of the server to purge its pool.\n   * @returns {Promise<void>} A promise that is resolved when the resources are purged\n   */\n  Pool.prototype.purge = function (address) {\n    return this._purgeKey(address.asKey());\n  };\n  /**\n   * Destroy all idle resources in this pool.\n   * @returns {Promise<void>} A promise that is resolved when the resources are purged\n   */\n  Pool.prototype.close = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this._closed = true;\n            return [4 /*yield*/, Promise.all(Object.keys(this._pools).map(function (key) {\n              return _this._purgeKey(key);\n            }))];\n          case 1:\n            /**\n             * The lack of Promise consuming was making the driver do not close properly in the scenario\n             * captured at result.test.js:it('should handle missing onCompleted'). The test was timing out\n             * because while wainting for the driver close.\n             *\n             * Consuming the Promise.all or by calling then or by awaiting in the result inside this method solved\n             * the issue somehow.\n             *\n             * PS: the return of this method was already awaited at PooledConnectionProvider.close, but the await bellow\n             * seems to be need also.\n             */\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Keep the idle resources for the provided addresses and purge the rest.\n   * @returns {Promise<void>} A promise that is resolved when the other resources are purged\n   */\n  Pool.prototype.keepAll = function (addresses) {\n    var _this = this;\n    var keysToKeep = addresses.map(function (a) {\n      return a.asKey();\n    });\n    var keysPresent = Object.keys(this._pools);\n    var keysToPurge = keysPresent.filter(function (k) {\n      return keysToKeep.indexOf(k) === -1;\n    });\n    return Promise.all(keysToPurge.map(function (key) {\n      return _this._purgeKey(key);\n    }));\n  };\n  /**\n   * Check if this pool contains resources for the given address.\n   * @param {ServerAddress} address the address of the server to check.\n   * @return {boolean} `true` when pool contains entries for the given key, <code>false</code> otherwise.\n   */\n  Pool.prototype.has = function (address) {\n    return address.asKey() in this._pools;\n  };\n  /**\n   * Get count of active (checked out of the pool) resources for the given key.\n   * @param {ServerAddress} address the address of the server to check.\n   * @return {number} count of resources acquired by clients.\n   */\n  Pool.prototype.activeResourceCount = function (address) {\n    return this._activeResourceCounts[address.asKey()] || 0;\n  };\n  Pool.prototype._acquire = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var key, pool, poolState, resource_1, numConnections, resource;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this._closed) {\n              throw (0, neo4j_driver_core_1.newError)('Pool is closed, it is no more able to serve requests.');\n            }\n            key = address.asKey();\n            pool = this._pools[key];\n            poolState = this._poolState[key];\n            if (!pool) {\n              pool = [];\n              poolState = new PoolState();\n              this._pools[key] = pool;\n              this._pendingCreates[key] = 0;\n              this._poolState[key] = poolState;\n            }\n            _a.label = 1;\n          case 1:\n            if (!pool.length) return [3 /*break*/, 5];\n            resource_1 = pool.pop();\n            if (!this._validate(resource_1)) return [3 /*break*/, 2];\n            if (this._removeIdleObserver) {\n              this._removeIdleObserver(resource_1);\n            }\n            // idle resource is valid and can be acquired\n            resourceAcquired(key, this._activeResourceCounts);\n            if (this._log.isDebugEnabled()) {\n              this._log.debug(resource_1 + \" acquired from the pool \" + key);\n            }\n            return [2 /*return*/, resource_1];\n          case 2:\n            return [4 /*yield*/, this._destroy(resource_1)];\n          case 3:\n            _a.sent();\n            _a.label = 4;\n          case 4:\n            return [3 /*break*/, 1];\n          case 5:\n            // Ensure requested max pool size\n            if (this._maxSize > 0) {\n              numConnections = this.activeResourceCount(address) + this._pendingCreates[key];\n              if (numConnections >= this._maxSize) {\n                // Will put this request in queue instead since the pool is full\n                return [2 /*return*/, null];\n              }\n            }\n            // there exist no idle valid resources, create a new one for acquisition\n            // Keep track of how many pending creates there are to avoid making too many connections.\n            this._pendingCreates[key] = this._pendingCreates[key] + 1;\n            _a.label = 6;\n          case 6:\n            _a.trys.push([6,, 8, 9]);\n            return [4 /*yield*/, this._create(address, function (address, resource) {\n              return _this._release(poolState, address, resource);\n            })];\n          case 7:\n            // Invoke callback that creates actual connection\n            resource = _a.sent();\n            resourceAcquired(key, this._activeResourceCounts);\n            if (this._log.isDebugEnabled()) {\n              this._log.debug(resource + \" created for the pool \" + key);\n            }\n            return [3 /*break*/, 9];\n          case 8:\n            this._pendingCreates[key] = this._pendingCreates[key] - 1;\n            return [7 /*endfinally*/];\n          case 9:\n            return [2 /*return*/, resource];\n        }\n      });\n    });\n  };\n  Pool.prototype._release = function (poolState, address, resource) {\n    return __awaiter(this, void 0, void 0, function () {\n      var key, pool;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            key = address.asKey();\n            pool = this._pools[key];\n            if (!(pool && poolState && poolState.isActive())) return [3 /*break*/, 4];\n            if (!!this._validate(resource)) return [3 /*break*/, 2];\n            if (this._log.isDebugEnabled()) {\n              this._log.debug(resource + \" destroyed and can't be released to the pool \" + key + \" because it is not functional\");\n            }\n            return [4 /*yield*/, this._destroy(resource)];\n          case 1:\n            _a.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            if (this._installIdleObserver) {\n              this._installIdleObserver(resource, {\n                onError: function onError(error) {\n                  _this._log.debug(\"Idle connection \" + resource + \" destroyed because of error: \" + error);\n                  var pool = _this._pools[key];\n                  if (pool) {\n                    _this._pools[key] = pool.filter(function (r) {\n                      return r !== resource;\n                    });\n                  }\n                  // let's not care about background clean-ups due to errors but just trigger the destroy\n                  // process for the resource, we especially catch any errors and ignore them to avoid\n                  // unhandled promise rejection warnings\n                  _this._destroy(resource).catch(function () {});\n                }\n              });\n            }\n            pool.push(resource);\n            if (this._log.isDebugEnabled()) {\n              this._log.debug(resource + \" released to the pool \" + key);\n            }\n            _a.label = 3;\n          case 3:\n            return [3 /*break*/, 6];\n          case 4:\n            // key has been purged, don't put it back, just destroy the resource\n            if (this._log.isDebugEnabled()) {\n              this._log.debug(resource + \" destroyed and can't be released to the pool \" + key + \" because pool has been purged\");\n            }\n            return [4 /*yield*/, this._destroy(resource)];\n          case 5:\n            _a.sent();\n            _a.label = 6;\n          case 6:\n            resourceReleased(key, this._activeResourceCounts);\n            this._processPendingAcquireRequests(address);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Pool.prototype._purgeKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var pool, poolState, destructionList, resource;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            pool = this._pools[key] || [];\n            poolState = this._poolState[key] || new PoolState();\n            destructionList = [];\n            while (pool.length) {\n              resource = pool.pop();\n              if (this._removeIdleObserver) {\n                this._removeIdleObserver(resource);\n              }\n              destructionList.push(this._destroy(resource));\n            }\n            poolState.close();\n            delete this._pools[key];\n            delete this._poolState[key];\n            return [4 /*yield*/, Promise.all(destructionList)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Pool.prototype._processPendingAcquireRequests = function (address) {\n    var _this = this;\n    var key = address.asKey();\n    var requests = this._acquireRequests[key];\n    var poolState = this._poolState[key];\n    if (requests) {\n      var pendingRequest_1 = requests.shift(); // pop a pending acquire request\n      if (pendingRequest_1) {\n        this._acquire(address).catch(function (error) {\n          // failed to acquire/create a new connection to resolve the pending acquire request\n          // propagate the error by failing the pending request\n          pendingRequest_1.reject(error);\n          return null;\n        }).then(function (resource) {\n          if (resource) {\n            // managed to acquire a valid resource from the pool\n            if (pendingRequest_1.isCompleted()) {\n              // request has been completed, most likely failed by a timeout\n              // return the acquired resource back to the pool\n              _this._release(poolState, address, resource);\n            } else {\n              // request is still pending and can be resolved with the newly acquired resource\n              pendingRequest_1.resolve(resource); // resolve the pending request with the acquired resource\n            }\n          }\n        });\n      } else {\n        delete this._acquireRequests[key];\n      }\n    }\n  };\n  return Pool;\n}();\n/**\n * Increment active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\nfunction resourceAcquired(key, activeResourceCounts) {\n  var currentCount = activeResourceCounts[key] || 0;\n  activeResourceCounts[key] = currentCount + 1;\n}\n/**\n * Decrement active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\nfunction resourceReleased(key, activeResourceCounts) {\n  var currentCount = activeResourceCounts[key] || 0;\n  var nextCount = currentCount - 1;\n  if (nextCount > 0) {\n    activeResourceCounts[key] = nextCount;\n  } else {\n    delete activeResourceCounts[key];\n  }\n}\nvar PendingRequest = /** @class */function () {\n  function PendingRequest(key, resolve, reject, timeoutId, log) {\n    this._key = key;\n    this._resolve = resolve;\n    this._reject = reject;\n    this._timeoutId = timeoutId;\n    this._log = log;\n    this._completed = false;\n  }\n  PendingRequest.prototype.isCompleted = function () {\n    return this._completed;\n  };\n  PendingRequest.prototype.resolve = function (resource) {\n    if (this._completed) {\n      return;\n    }\n    this._completed = true;\n    clearTimeout(this._timeoutId);\n    if (this._log.isDebugEnabled()) {\n      this._log.debug(resource + \" acquired from the pool \" + this._key);\n    }\n    this._resolve(resource);\n  };\n  PendingRequest.prototype.reject = function (error) {\n    if (this._completed) {\n      return;\n    }\n    this._completed = true;\n    clearTimeout(this._timeoutId);\n    this._reject(error);\n  };\n  return PendingRequest;\n}();\nvar PoolState = /** @class */function () {\n  function PoolState() {\n    this._active = true;\n  }\n  PoolState.prototype.isActive = function () {\n    return this._active;\n  };\n  PoolState.prototype.close = function () {\n    this._active = false;\n  };\n  return PoolState;\n}();\nexports.default = Pool;","map":null,"metadata":{},"sourceType":"script"}