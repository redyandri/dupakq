{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2]) _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar observers_1 = require(\"./internal/observers\");\nvar util_1 = require(\"./internal/util\");\nvar error_1 = require(\"./error\");\nvar result_1 = __importDefault(require(\"./result\"));\nvar transaction_1 = __importDefault(require(\"./transaction\"));\nvar connection_holder_1 = require(\"./internal/connection-holder\");\nvar constants_1 = require(\"./internal/constants\");\nvar transaction_executor_1 = require(\"./internal/transaction-executor\");\nvar bookmark_1 = require(\"./internal/bookmark\");\nvar tx_config_1 = require(\"./internal/tx-config\");\n/**\n * A Session instance is used for handling the connection and\n * sending queries through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\nvar Session = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Object} args\n   * @param {string} args.mode the default access mode for this session.\n   * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\n   * @param {Bookmark} args.bookmark - The initial bookmark for this session.\n   * @param {string} args.database the database name\n   * @param {Object} args.config={} - This driver configuration.\n   * @param {boolean} args.reactive - Whether this session should create reactive streams\n   * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\n   * @param {string} args.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\n   */\n  function Session(_a) {\n    var mode = _a.mode,\n      connectionProvider = _a.connectionProvider,\n      bookmark = _a.bookmark,\n      database = _a.database,\n      config = _a.config,\n      reactive = _a.reactive,\n      fetchSize = _a.fetchSize,\n      impersonatedUser = _a.impersonatedUser;\n    this._mode = mode;\n    this._database = database;\n    this._reactive = reactive;\n    this._fetchSize = fetchSize;\n    this._onDatabaseNameResolved = this._onDatabaseNameResolved.bind(this);\n    this._readConnectionHolder = new connection_holder_1.ConnectionHolder({\n      mode: constants_1.ACCESS_MODE_READ,\n      database: database,\n      bookmark: bookmark,\n      connectionProvider: connectionProvider,\n      impersonatedUser: impersonatedUser,\n      onDatabaseNameResolved: this._onDatabaseNameResolved\n    });\n    this._writeConnectionHolder = new connection_holder_1.ConnectionHolder({\n      mode: constants_1.ACCESS_MODE_WRITE,\n      database: database,\n      bookmark: bookmark,\n      connectionProvider: connectionProvider,\n      impersonatedUser: impersonatedUser,\n      onDatabaseNameResolved: this._onDatabaseNameResolved\n    });\n    this._open = true;\n    this._hasTx = false;\n    this._impersonatedUser = impersonatedUser;\n    this._lastBookmark = bookmark || bookmark_1.Bookmark.empty();\n    this._transactionExecutor = _createTransactionExecutor(config);\n    this._onComplete = this._onCompleteCallback.bind(this);\n    this._databaseNameResolved = this._database !== '';\n  }\n  /**\n   * Run Cypher query\n   * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n   * or with the query and parameters as separate arguments.\n   *\n   * @public\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n   * @return {Result} New Result.\n   */\n  Session.prototype.run = function (query, parameters, transactionConfig) {\n    var _this = this;\n    var _a = (0, util_1.validateQueryAndParameters)(query, parameters),\n      validatedQuery = _a.validatedQuery,\n      params = _a.params;\n    var autoCommitTxConfig = transactionConfig ? new tx_config_1.TxConfig(transactionConfig) : tx_config_1.TxConfig.empty();\n    return this._run(validatedQuery, params, function (connection) {\n      _this._assertSessionIsOpen();\n      return connection.protocol().run(validatedQuery, params, {\n        bookmark: _this._lastBookmark,\n        txConfig: autoCommitTxConfig,\n        mode: _this._mode,\n        database: _this._database,\n        impersonatedUser: _this._impersonatedUser,\n        afterComplete: _this._onComplete,\n        reactive: _this._reactive,\n        fetchSize: _this._fetchSize\n      });\n    });\n  };\n  Session.prototype._run = function (query, parameters, customRunner) {\n    var connectionHolder = this._connectionHolderWithMode(this._mode);\n    var observerPromise;\n    if (!this._open) {\n      observerPromise = Promise.resolve(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Cannot run query in a closed session.')\n      }));\n    } else if (!this._hasTx && connectionHolder.initializeConnection()) {\n      observerPromise = connectionHolder.getConnection().then(function (connection) {\n        return customRunner(connection);\n      }).catch(function (error) {\n        return Promise.resolve(new observers_1.FailedObserver({\n          error: error\n        }));\n      });\n    } else {\n      observerPromise = Promise.resolve(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.')\n      }));\n    }\n    return new result_1.default(observerPromise, query, parameters, connectionHolder);\n  };\n  Session.prototype._acquireConnection = function (connectionConsumer) {\n    return __awaiter(this, void 0, void 0, function () {\n      var promise, connectionHolder;\n      var _this = this;\n      return __generator(this, function (_a) {\n        connectionHolder = this._connectionHolderWithMode(this._mode);\n        if (!this._open) {\n          promise = Promise.reject((0, error_1.newError)('Cannot run query in a closed session.'));\n        } else if (!this._hasTx && connectionHolder.initializeConnection()) {\n          promise = connectionHolder.getConnection().then(function (connection) {\n            return connectionConsumer(connection);\n          }).then(function (result) {\n            return __awaiter(_this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4 /*yield*/, connectionHolder.releaseConnection()];\n                  case 1:\n                    _a.sent();\n                    return [2 /*return*/, result];\n                }\n              });\n            });\n          });\n        } else {\n          promise = Promise.reject((0, error_1.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.'));\n        }\n        return [2 /*return*/, promise];\n      });\n    });\n  };\n  /**\n   * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n   * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n   *\n   * While a transaction is open the session cannot be used to run queries outside the transaction.\n   *\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n   * @returns {Transaction} New Transaction.\n   */\n  Session.prototype.beginTransaction = function (transactionConfig) {\n    // this function needs to support bookmarks parameter for backwards compatibility\n    // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n    // that's why we need to check parameter type and decide how to interpret the value\n    var arg = transactionConfig;\n    var txConfig = tx_config_1.TxConfig.empty();\n    if (arg) {\n      txConfig = new tx_config_1.TxConfig(arg);\n    }\n    return this._beginTransaction(this._mode, txConfig);\n  };\n  Session.prototype._beginTransaction = function (accessMode, txConfig) {\n    if (!this._open) {\n      throw (0, error_1.newError)('Cannot begin a transaction on a closed session.');\n    }\n    if (this._hasTx) {\n      throw (0, error_1.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');\n    }\n    var mode = Session._validateSessionMode(accessMode);\n    var connectionHolder = this._connectionHolderWithMode(mode);\n    connectionHolder.initializeConnection();\n    this._hasTx = true;\n    var tx = new transaction_1.default({\n      connectionHolder: connectionHolder,\n      impersonatedUser: this._impersonatedUser,\n      onClose: this._transactionClosed.bind(this),\n      onBookmark: this._updateBookmark.bind(this),\n      onConnection: this._assertSessionIsOpen.bind(this),\n      reactive: this._reactive,\n      fetchSize: this._fetchSize\n    });\n    tx._begin(this._lastBookmark, txConfig);\n    return tx;\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n  Session.prototype._assertSessionIsOpen = function () {\n    if (!this._open) {\n      throw (0, error_1.newError)('You cannot run more transactions on a closed session.');\n    }\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n  Session.prototype._transactionClosed = function () {\n    this._hasTx = false;\n  };\n  /**\n   * Return the bookmark received following the last completed {@link Transaction}.\n   *\n   * @return {string[]} A reference to a previous transaction.\n   */\n  Session.prototype.lastBookmark = function () {\n    return this._lastBookmark.values();\n  };\n  /**\n   * Execute given unit of work in a {@link READ} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   */\n  Session.prototype.readTransaction = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig);\n    return this._runTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n  };\n  /**\n   * Execute given unit of work in a {@link WRITE} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   */\n  Session.prototype.writeTransaction = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig);\n    return this._runTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n  };\n  Session.prototype._runTransaction = function (accessMode, transactionConfig, transactionWork) {\n    var _this = this;\n    return this._transactionExecutor.execute(function () {\n      return _this._beginTransaction(accessMode, transactionConfig);\n    }, transactionWork);\n  };\n  /**\n   * Sets the resolved database name in the session context.\n   * @private\n   * @param {string|undefined} database The resolved database name\n   * @returns {void}\n   */\n  Session.prototype._onDatabaseNameResolved = function (database) {\n    if (!this._databaseNameResolved) {\n      var normalizedDatabase = database || '';\n      this._database = normalizedDatabase;\n      this._readConnectionHolder.setDatabase(normalizedDatabase);\n      this._writeConnectionHolder.setDatabase(normalizedDatabase);\n      this._databaseNameResolved = true;\n    }\n  };\n  /**\n   * Update value of the last bookmark.\n   * @private\n   * @param {Bookmark} newBookmark - The new bookmark.\n   * @returns {void}\n   */\n  Session.prototype._updateBookmark = function (newBookmark) {\n    if (newBookmark && !newBookmark.isEmpty()) {\n      this._lastBookmark = newBookmark;\n    }\n  };\n  /**\n   * Close this session.\n   * @return {Promise}\n   */\n  Session.prototype.close = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._open) return [3 /*break*/, 3];\n            this._open = false;\n            this._transactionExecutor.close();\n            return [4 /*yield*/, this._readConnectionHolder.close()];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this._writeConnectionHolder.close()];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Session.prototype._connectionHolderWithMode = function (mode) {\n    if (mode === constants_1.ACCESS_MODE_READ) {\n      return this._readConnectionHolder;\n    } else if (mode === constants_1.ACCESS_MODE_WRITE) {\n      return this._writeConnectionHolder;\n    } else {\n      throw (0, error_1.newError)('Unknown access mode: ' + mode);\n    }\n  };\n  /**\n   * @private\n   * @param {Object} meta Connection metadatada\n   * @returns {void}\n   */\n  Session.prototype._onCompleteCallback = function (meta) {\n    this._updateBookmark(new bookmark_1.Bookmark(meta.bookmark));\n  };\n  /**\n   * @protected\n   */\n  Session._validateSessionMode = function (rawMode) {\n    var mode = rawMode || constants_1.ACCESS_MODE_WRITE;\n    if (mode !== constants_1.ACCESS_MODE_READ && mode !== constants_1.ACCESS_MODE_WRITE) {\n      throw (0, error_1.newError)('Illegal session mode ' + mode);\n    }\n    return mode;\n  };\n  return Session;\n}();\n/**\n * @private\n * @param {object} config\n * @returns {TransactionExecutor} The transaction executor\n */\nfunction _createTransactionExecutor(config) {\n  var maxRetryTimeMs = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;\n  return new transaction_executor_1.TransactionExecutor(maxRetryTimeMs);\n}\nexports.default = Session;","map":null,"metadata":{},"sourceType":"script"}