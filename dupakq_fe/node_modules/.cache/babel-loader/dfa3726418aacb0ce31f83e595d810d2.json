{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionExecutor = void 0;\nvar error_1 = require(\"../error\");\nvar retry_strategy_1 = require(\"./retry-strategy\");\nvar DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds\nvar DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds\nvar DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;\nvar DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;\nvar TransactionExecutor = /** @class */function () {\n  function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {\n    this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);\n    this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);\n    this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);\n    this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);\n    this._inFlightTimeoutIds = [];\n    this._verifyAfterConstruction();\n  }\n  TransactionExecutor.prototype.execute = function (transactionCreator, transactionWork) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n    }).catch(function (error) {\n      var retryStartTimeMs = Date.now();\n      var retryDelayMs = _this._initialRetryDelayMs;\n      return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);\n    });\n  };\n  TransactionExecutor.prototype.close = function () {\n    // cancel all existing timeouts to prevent further retries\n    this._inFlightTimeoutIds.forEach(function (timeoutId) {\n      return clearTimeout(timeoutId);\n    });\n    this._inFlightTimeoutIds = [];\n  };\n  TransactionExecutor.prototype._retryTransactionPromise = function (transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {\n    var _this = this;\n    var elapsedTimeMs = Date.now() - retryStartTime;\n    if (elapsedTimeMs > this._maxRetryTimeMs || !(0, retry_strategy_1.canRetryOn)(error)) {\n      return Promise.reject(error);\n    }\n    return new Promise(function (resolve, reject) {\n      var nextRetryTime = _this._computeDelayWithJitter(retryDelayMs);\n      var timeoutId = setTimeout(function () {\n        // filter out this timeoutId when time has come and function is being executed\n        _this._inFlightTimeoutIds = _this._inFlightTimeoutIds.filter(function (id) {\n          return id !== timeoutId;\n        });\n        _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n      }, nextRetryTime);\n      // add newly created timeoutId to the list of all in-flight timeouts\n      _this._inFlightTimeoutIds.push(timeoutId);\n    }).catch(function (error) {\n      var nextRetryDelayMs = retryDelayMs * _this._multiplier;\n      return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);\n    });\n  };\n  TransactionExecutor.prototype._executeTransactionInsidePromise = function (transactionCreator, transactionWork, resolve, reject) {\n    var _this = this;\n    var tx;\n    try {\n      tx = transactionCreator();\n    } catch (error) {\n      // failed to create a transaction\n      reject(error);\n      return;\n    }\n    var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);\n    resultPromise.then(function (result) {\n      return _this._handleTransactionWorkSuccess(result, tx, resolve, reject);\n    }).catch(function (error) {\n      return _this._handleTransactionWorkFailure(error, tx, reject);\n    });\n  };\n  TransactionExecutor.prototype._safeExecuteTransactionWork = function (tx, transactionWork) {\n    try {\n      var result = transactionWork(tx);\n      // user defined callback is supposed to return a promise, but it might not; so to protect against an\n      // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a\n      // validation step without type checks\n      return Promise.resolve(result);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n  TransactionExecutor.prototype._handleTransactionWorkSuccess = function (result, tx, resolve, reject) {\n    if (tx.isOpen()) {\n      // transaction work returned resolved promise and transaction has not been committed/rolled back\n      // try to commit the transaction\n      tx.commit().then(function () {\n        // transaction was committed, return result to the user\n        resolve(result);\n      }).catch(function (error) {\n        // transaction failed to commit, propagate the failure\n        reject(error);\n      });\n    } else {\n      // transaction work returned resolved promise and transaction is already committed/rolled back\n      // return the result returned by given transaction work\n      resolve(result);\n    }\n  };\n  TransactionExecutor.prototype._handleTransactionWorkFailure = function (error, tx, reject) {\n    if (tx.isOpen()) {\n      // transaction work failed and the transaction is still open, roll it back and propagate the failure\n      tx.rollback().catch(function (ignore) {\n        // ignore the rollback error\n      }).then(function () {\n        return reject(error);\n      }); // propagate the original error we got from the transaction work\n    } else {\n      // transaction is already rolled back, propagate the error\n      reject(error);\n    }\n  };\n  TransactionExecutor.prototype._computeDelayWithJitter = function (delayMs) {\n    var jitter = delayMs * this._jitterFactor;\n    var min = delayMs - jitter;\n    var max = delayMs + jitter;\n    return Math.random() * (max - min) + min;\n  };\n  TransactionExecutor.prototype._verifyAfterConstruction = function () {\n    if (this._maxRetryTimeMs < 0) {\n      throw (0, error_1.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);\n    }\n    if (this._initialRetryDelayMs < 0) {\n      throw (0, error_1.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);\n    }\n    if (this._multiplier < 1.0) {\n      throw (0, error_1.newError)('Multiplier should be >= 1.0: ' + this._multiplier);\n    }\n    if (this._jitterFactor < 0 || this._jitterFactor > 1) {\n      throw (0, error_1.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);\n    }\n  };\n  return TransactionExecutor;\n}();\nexports.TransactionExecutor = TransactionExecutor;\nfunction _valueOrDefault(value, defaultValue) {\n  if (value || value === 0) {\n    return value;\n  }\n  return defaultValue;\n}","map":null,"metadata":{},"sourceType":"script"}